<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Qt on ZERO GmbH Tech Blog</title><link>https://blog.zero-iee.com/tags/qt/</link><description>ZERO GmbH Tech Blog (Qt)</description><generator>Hugo -- gohugo.io</generator><language>de</language><lastBuildDate>Tue, 26 Sep 2023 09:39:39 +0200</lastBuildDate><atom:link href="https://blog.zero-iee.com/tags/qt/index.xml" rel="self" type="application/rss+xml"/><item><title>DSI Output Fehler beim Start einer Qt Anwendung verhindern (Raspberry Pi)</title><link>https://blog.zero-iee.com/posts/resolving-qt-dsi-failed-to-move-flip-permission-denied-error/</link><pubDate>Tue, 26 Sep 2023 09:39:39 +0200</pubDate><guid>https://blog.zero-iee.com/posts/resolving-qt-dsi-failed-to-move-flip-permission-denied-error/</guid><description>&lt;p>Gestern haben wir bei der Fertigstellung einiger unserer AMPS Einheiten mit Display und Qt-Applikation einen Fehler festgestellt, der dazu geführt hat, dass die Anwendung in seltenen Fällen nicht korrekt gestartet werden kann und crasht. Der Fehler sieht wie folgt aus:&lt;/p>
&lt;pre tabindex="0">&lt;code>-- Logs begin at Mon 2023-09-25 12:17:01 CEST, end at Mon 2023-09-25 12:32:43 CEST. --
Sep 25 12:32:24 0601-010200-0012 systemd[1]: Started app.
Sep 25 12:32:27 0601-010200-0012 tester[444]: Failed to move cursor on screen DSI1: -13
Sep 25 12:32:27 0601-010200-0012 tester[444]: Failed to move cursor on screen DSI1: -13
Sep 25 12:32:27 0601-010200-0012 tester[444]: Could not set cursor on screen DSI1: -13
Sep 25 12:32:28 0601-010200-0012 tester[444]: Could not set DRM mode for screen DSI1 (Permission denied)
Sep 25 12:32:28 0601-010200-0012 tester[444]: Could not queue DRM page flip on screen DSI1 (Permission denied)
Sep 25 12:32:29 0601-010200-0012 tester[444]: Could not queue DRM page flip on screen DSI1 (Permission denied)
&lt;/code>&lt;/pre>&lt;p>&amp;ldquo;In seltenen Fällen&amp;rdquo;, weil der Bug offenbar Timing-abhängig war. Weil uns die Fehlermeldungen allerdings nicht ganz unbekannt waren, konnten wir relativ schnell herausfinden, woher sie kamen:&lt;/p>
&lt;p>Unsere Anwendung läuft im EGLFS Betrieb und beansprucht die vollständige Kontrolle über das Display. Im Hintergrund läuft kein XServer, Wayland oder ähnliches. Die Fehlermeldungen weisen auf ein Berechtigungsproblem hin, kommen aber eigentlich daher, dass bereits eine andere Anwendung Kontrolle über das Display ausübt.&lt;/p>
&lt;p>In unserem Fall: Der Boot-Splashscreen (&lt;code>plymouth&lt;/code>) unserer Rasbian Distribution. Der Fehler tritt nur ca 1-2 von 10 Mal auf, weil systemd die Anwendung in den meisten Fällen zu einem Zeitpunkt startet, zu dem das Display bereits wieder freigegeben wurde. Je nach Bootzeit - und die kann ja bekanntlich leicht variieren - kann es aber auch passieren, dass das Timing so ungünstig ist, dass das Splashscreen das Display noch &lt;em>nicht&lt;/em> freigegeben hat, wenn unsere Anwendung dieses bereits nutzen will.&lt;/p>
&lt;p>Das Problem lässt sich glücklicherweise beseitigen, indem zum systemd Service unserer Anwendung mittels &lt;code>After&lt;/code> eine weitere Abhängigkeit hinzugefügt, z.B.&lt;/p>
&lt;pre>&lt;code>[Unit]
Description=App
After=systemd-user-sessions.service plymouth-quit.service
[Service]
Type=simple
User=pi
Group=pi
ExecStart=/opt/tester/bin/tester -platform=eglfs
[Install]
WantedBy=multi-user.target
&lt;/code>&lt;/pre>
&lt;p>&lt;em>Übrigens: In diesem Zusammenhang kann es sich auch lohnen, zu prüfen, ob der Benutzer, welcher die Applikation ausführt, in der Benutzergruppe &amp;ldquo;render&amp;rdquo; ist. Die Gruppenzugehörigkeit wird benötigt, um als Anwendung überhaupt via eglfs aus das Display zugreifen zu dürfen.&lt;/em>&lt;/p></description></item><item><title>Qt Webengine (Chromium): Too Many Open Files</title><link>https://blog.zero-iee.com/posts/qt-webengine-chromium-too-many-open-files/</link><pubDate>Wed, 08 Feb 2023 10:36:44 +0100</pubDate><guid>https://blog.zero-iee.com/posts/qt-webengine-chromium-too-many-open-files/</guid><description>&lt;p>Wie bereits in früheren Blogposts erwähnt, nutzen wir innerhalb einer Qt Quick Anwendung die Chromium-basierte Qt WebEngine, um Webinhalte darstellen zu lassen. Im Laufe der Entwicklung haben wir allerdings einen unerfreulichen Bug entdeckt, der unsere Anwendung nach einiger Zeit im laufenden Betrieb abstürzen lässt. Zunächst friert das Web-Fenster ein - etwas später folgt dann der Rest der Anwendung, bis die Anwendung schließlich beendet wird.&lt;/p>
&lt;p>In diesem Beitrag stellen wir einen Workaround vor, der für uns funktioniert hat.&lt;/p>
&lt;p>Zunächst galt es, den Ursprung für die Crashes zu ermitteln. Da die Anwendung neben dem WebEngine-Teil auch noch aus anderen, komplexeren Modulen besteht, fiel der Verdacht nicht gleich auf den WebEngine-Anteil. Viel wahrscheinlicher schien zunächst ein klassischer Memory Leak Bug zu sein. Also beispielsweise das neue Erstellen von C++ Objekten, ohne invalide oder nicht mehr benötigte Objekte hinterher zu entfernen und ggf. vorhandene Referenzen zu entfernen.&lt;/p>
&lt;p>Die Fehlermeldung im Qt Creator Log war:&lt;/p>
&lt;pre tabindex="0">&lt;code>[...] ERROR:broker_posix.cc(46) Received unexpected number of handles
[...] ERROR:platform_shared_memory_region_posix.cc(249) Creating shared memory in /dev/shm/.org.chromium.Chromium.Sf3dsf: Too many open files (24)
&lt;/code>&lt;/pre>&lt;p>Hier findet sich schon ein erstes Indiz, dass die Qt WebEngine etwas damit zu tun haben könnte. Dieser Teil unserer Anwendung scheint zu viele File Handles zu öffnen. Der Linux-Kernel verfügt über einen Kontrollmechanismus, der Anwendungen in der Zahl ihrer offenen File Handles beschränkt, sodass Ressourcenprobleme durch Amok-laufende Prozesse unwahrscheinlicher werden. Über das &lt;code>ulimit&lt;/code> Tool lassen sich die aktuell geltenden Einschränkungen einsehen (im Gültigkeitsbereich der Shell).&lt;/p>
&lt;p>Für einzelne Prozesse können die geltenden Limits mittels &lt;code>cat /proc/&amp;lt;PID&amp;gt;/limits&lt;/code> abgerufen werden. Über ein &lt;code>ls -1 /proc/&amp;lt;PID&amp;gt;/fd | wc -l&lt;/code> wird die Anzahl der offenen File Handles für einen Prozess zurückgegeben.&lt;/p>
&lt;p>Für unsere Anwendung lag die Zahl viel zu hoch. Langsam bei ca. 7.000 Handles beginnend entwickelte sich die Zahl der offenen Handles extrem schnell. Nach wenigen Minuten lag sie bereits im sechsstelligen Bereich.&lt;/p>
&lt;p>Je nach Benutzung der Webanwendung stieg die Zahl kaum oder sehr schnell. Vor allem bei intensiverer Benutzung des Web-Anteils der Anwendung stieg die Zahl rasant an. Da unsere WebApp eine beträchtliche Anzahl von Ajax-Requests im Hintergrund an einen REST API Server schickt, fiel der Verdacht zunächst auf offene Verbindungen seitens der Webanwendung. Hatte Chromium einen Bug und hielt Verbindungen aus irgendeinem Grund offen?&lt;/p>
&lt;p>Nach Deaktivierung der meisten Anfragen war schnell klar, dass die Hintergrundanfragen die Zahl der offenen File Handles nicht bedeutend beeinflusste. Alles andere wäre auch tatsächlich ein schwerer Bug in Chrome gewesen. Doch wieso beeinflusste die Benutzung der Webanwendung die Anzahl der offenen Handles dennoch so stark?&lt;/p>
&lt;p>Durch weiteres Experimentieren fanden wir heraus, dass unser Javascript-Code innerhalb der WebApp nichts mit dem Phänomen zu tun hatte. Stattdessen erhöhte sich die Anzahl der File Handles mit jeder visuellen Änderung innerhalb der WebEngine. Änderte sich eine Zahl oder wurde eine Animation aktiviert, schoss der Zähler in die Höhe. Änderte sich nichts auf der dargestellten Website, änderten sich auch die File Handles kaum.&lt;/p>
&lt;p>Hiermit waren wir mit unserem Code also raus. Der Bug lang im Verantwortungsbereich von Chromium, Qt oder Grafiktreiber-Code. Abschließend konnten wir die Ursache mangels Einsicht in die Funktionsweise der involvierten Komponenten nicht klären - Aber nach einigen weiteren Experimenten gelang es uns, unsere Anwendung so anzupassen, dass das Problem nicht mehr auftritt.&lt;/p>
&lt;p>Der Schlüssel war am Ende, in der Qt-Anwendung folgende Einstellung zu setzen:&lt;/p>
&lt;pre tabindex="0">&lt;code>QCoreApplication::setAttribute(Qt::AA_UseSoftwareOpenGL);
&lt;/code>&lt;/pre>&lt;p>Eigentlich bewirkt die &lt;a href="https://doc.qt.io/qt-6/qt.html#ApplicationAttribute-enum">Einstellung&lt;/a>, dass eine softwaregestützte, alternative OpenGL Implementierung genutzt wird. In den meisten Fällen wohl keine besonders attraktive Option. In unserem Fall bewahrt sie uns aber vor den Problemen, die wir mit der Standardeinstellung hatten und verursacht keine weiteren relevanten Nebeneffekte. Die Performance ist für unseren Anwendungsfall okay, sodass wir hiermit leben können.&lt;/p>
&lt;p>Als Ursache bleibt eine Inkompatibilität oder ein Bug zwischen unserem Raspberry Pi 4 Grafiktreiber und/oder Chromium bzw. der Qt WebEngine zu vermuten. Wie sich schon an anderer Stelle herausgestellt hat, kann der Raspberry Pi Grafikstack verwirrend und in bestimmten Konstellationen fehlerbehaftet sein. Das ist allerdings ein &amp;ldquo;Rabbit hole&amp;rdquo; für ein andermal &amp;hellip;&lt;/p></description></item><item><title>Schlechte Qt Grafikperformance mit Raspi4</title><link>https://blog.zero-iee.com/posts/schlechte-qt-grafik-performance-mit-raspi4/</link><pubDate>Tue, 07 Feb 2023 08:19:47 +0100</pubDate><guid>https://blog.zero-iee.com/posts/schlechte-qt-grafik-performance-mit-raspi4/</guid><description>&lt;p>Während der Entwicklung einer Qt-basierten Anwendung auf einem Raspberry Pi 4 (CM) sind wir von der ZERO GmbH vor ein paar Tagen auf ein kurioses Problem gestoßen: Die Anwendung beinhaltet zwei Anwendungsfenster - ein QT Quick Fenster und ein weiteres Fenster, das mittels WebEngine (Chromium) eine Webanwendung darstellt. Die Inhalte in beiden Fenstern wurden während des Debuggings und beim manuellen Starten der Binärdatei aus der Kommandozeile heraus flüssig dargestellt. Bei Animationen und Mausbewegungen konnten wir keine bemerkenswerten Ruckler feststellen.&lt;/p>
&lt;p>Doch nach einem Start während des Boot-Prozesses durch ein Systemd Service-File sah die Sache schon ganz anders aus: Die Darstellung ruckelte stark und die CPU-Auslastung lag bereits bei einfachen Texteinblendungen bei ca 80 %.&lt;/p>
&lt;p>Wir konnten einen Zusammenhang zwischen dem Startzeitpunkt der Anwendung und der Performance feststellen. In frühen Bootphasen war die Performance schlecht - bei späterer Ausführung lief die Anwendung flüssig. Durch ein &amp;ldquo;sleep&amp;rdquo; Kommando in unserem Systemd Service File konnten wir den Zusammenhang verdeutlichen:&lt;/p>
&lt;pre tabindex="0">&lt;code>[Unit]
Description=App
[Service]
User=pi
Group=pi
Type=simple
ExecStart=/bin/bash -c &amp;#39;sleep 10; /opt/myapp/myapp -platform=eglfs&amp;#39;
[Install]
WantedBy=multi-user.target
&lt;/code>&lt;/pre>&lt;p>Alleine schon eine Verzögerung der Ausführung um 10 Sekunden führte zum gewünschten Ergebnis. Dies war jedoch keine Zufriedenstellende Lösung - schließlich wollten wir die Qt-Anwendung so schnell wie möglich starten und nicht unnötig Zeit verlieren, ohne den Grund für das Verhalten zu kennen.&lt;/p>
&lt;p>Ein Blick in das Systemlog offenbarte schließlich, dass unsere Anwendung den LLVMpipe Rasterizer nutze, wenn sie über ein Service-File gestartet wurde:&lt;/p>
&lt;pre tabindex="0">&lt;code>&amp;#34;Feb 03 04:33:29 raspberrypi bash[470]: Running on a software rasterizer (LLVMpipe), expect limited performance.&amp;#34;
&lt;/code>&lt;/pre>&lt;p>Letztendlich konnten wir das Performanceproblem nach einigen Websuchen durch ein Hinzufügen unseres &lt;code>pi&lt;/code> Benutzers zur Benutzergruppe &lt;code>render&lt;/code> (und einen Anschließenden Neustart) beheben:&lt;/p>
&lt;pre tabindex="0">&lt;code>sudo usermod -aG render pi
&lt;/code>&lt;/pre>&lt;p>Nach &lt;a href="https://www.hardwareluxx.de/community/threads/raspberry-pi-os-und-ein-paar-fehler-beim-%C3%B6ffnen-eines-programmes.1272595/post-27563953">Aussage des Forennutzers &lt;em>&amp;ldquo;cRaZy-biScuiT&amp;rdquo;&lt;/em>&lt;/a> wird damit ein Bug behoben, der dafür sorgt, dass Anwendungen unter dem &lt;code>pi&lt;/code> User keine hardwarebeschleunigten Anwendungen ausführen können.&lt;/p>
&lt;p>Unsere Qt-Anwendung startete nun auch schon in früheren Bootphasen inkl. Hardwareunterstützung und die Performance war wie erwartet.&lt;/p>
&lt;p>Bisher können wir allerdings nicht erklären, wieso das Problem zu späteren Startzeitpunkten nicht auftrat. Wir vermuten eine externe Beeinflussung evtl. durch später startende, dritte Anwendungen, die dafür sorgte, dass die Hardwarebeschleunigung zu diesen Zeitpunkten dennoch zur Verfügung stand.&lt;/p></description></item><item><title>Qt 5.15.2 mit WebEngine (Chromium) bauen - RAM-Verbrauch begrenzen</title><link>https://blog.zero-iee.com/posts/qt-5.15.2-mit-webengine-ram-begrenzen/</link><pubDate>Wed, 11 Jan 2023 14:19:06 +0100</pubDate><guid>https://blog.zero-iee.com/posts/qt-5.15.2-mit-webengine-ram-begrenzen/</guid><description>&lt;p>Beim Kompilieren von Qt 5.15.2 aus den offiziellen Open Source Quellen sind wir in Kombination mit unserem Buildserver auf ein Problem getoßen: Der Buildprozess wurde beim Kompilieren der Chromium-basierten &amp;ldquo;WebEngine&amp;rdquo; Komponente mit zunächst mysteriösen Fehlermeldungen unterbrochen. Ein Blick in das Kernellog mittels &lt;code>dmesg -w&lt;/code> offenbarte dann schnell, dass der sog. OOM-Killer des Linux-Kernels zugeschlagen hatte. Offenbar war der RAM-Verbrauch des Buildprozesses so speicherintensiv, dass der Prozess abgebrochen werden musste, um das Betriebssystem lauffähig zu halten.&lt;/p>
&lt;p>Doch wie konnte das sein? Unser Buildserver verfügt über 32 GB RAM und 24 CPU-Kerne. Eine durchaus leistungsstarke Machine. Sie sollte eigentlich nicht so schnell an Leistungsgrenzen kommen.&lt;/p>
&lt;p>Das Problem wird durch zwei Faktoren verursacht. Zum einen ist das Bauen der Chromium Browser-Engine extrem speicherintensiv. Generell werden &lt;a href="https://chromium.googlesource.com/chromium/src/+/main/docs/linux/build_instructions.md">nicht weniger als 16 GB RAM empfohlen&lt;/a>. In unserem Fall kommt aber noch ein weiteres Problem hinzu: Per default erstellt &amp;ldquo;Ninja&amp;rdquo; - das in Chromium eingesetzte Buildsystem - für jeden verfügbaren virtuellen CPU Core einen Build-Thread, damit der Buildprozess maximal parallelisiert wird. Was für einen haushaltsüblichen PC mit 16 GB RAM noch gut funktionieren mag, zwingt unseren Buildserver mit seinen 24 Cores allerdings in die Knie. Jeder einzelne Thread braucht eine nicht zu unterschätzende Menge RAM. Am Ende stimmt bei unserem Server das Verhältnis aus CPU-Cores und verfügbarem RAM nicht mehr, sodass der Buildvorgang abbricht.&lt;/p>
&lt;p>Das Problem lässt sich verhindern, wenn wir die Anzahl der zu nutzenden Ninja-Threads künstlich verkleinern - wenn wir also nicht mit 24 CPU-Kernen bauen, sondern beispielsweise nur mit 18.&lt;/p>
&lt;p>Dazu kann vor einem &lt;code>make -j$(nproc)&lt;/code> die Umgebungsvariable &lt;code>NINJAJOBS&lt;/code> gesetzt werden. Anders, als man vielleicht vermuten würde &lt;em>(und anders, als es im &lt;a href="https://www.linuxfromscratch.org/blfs/view/svn/x/qtwebengine.html">LFS-Handbuch&lt;/a> beschrieben wird)&lt;/em>, wird hier allerdings nicht einfach nur eine Zahl hinterlegt, sondern der vollständige &lt;code>-j&lt;/code> &lt;a href="https://manpages.debian.org/testing/ninja-build/ninja.1.en.html">Parameter von Ninja&lt;/a>:&lt;/p>
&lt;pre>&lt;code>export NINJAJOBS=&amp;quot;-j16&amp;quot;
&lt;/code>&lt;/pre>
&lt;p>Wird darauf folgend ein &lt;code>make&lt;/code> ausgeführt, werden die üblichen Qt Komponenten mit allen Cores kompiliert, während die Ninja-basierten Anteile (in diesem Fall Chromium als Teil der WebEngine) mit weniger CPU Kernen gebaut werden, um den RAM zu schonen.&lt;/p>
&lt;p>Für unsere Kombination von 32 GB RAM und 24 CPU Cores haben wir experimentell eine Anzahl von 16 Kernel ermittelt, mit denen unser Buildprozess noch durchläuft. Mit nur 8 CPU-Kernen hatte die RAM-Auslastung bei ca 12 GB ihren Peak.&lt;/p></description></item></channel></rss>