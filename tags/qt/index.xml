<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>qt on ZERO GmbH Tech Blog</title><link>https://blog.zero-iee.com/tags/qt/</link><description>ZERO GmbH Tech Blog (qt)</description><generator>Hugo -- gohugo.io</generator><language>de-de</language><lastBuildDate>Tue, 07 Feb 2023 08:19:47 +0100</lastBuildDate><atom:link href="https://blog.zero-iee.com/tags/qt/index.xml" rel="self" type="application/rss+xml"/><item><title>Schlechte Qt Grafikperformance mit Raspi4</title><link>https://blog.zero-iee.com/posts/schlechte-qt-grafik-performance-mit-raspi4/</link><pubDate>Tue, 07 Feb 2023 08:19:47 +0100</pubDate><guid>https://blog.zero-iee.com/posts/schlechte-qt-grafik-performance-mit-raspi4/</guid><description>&lt;p>Während der Entwicklung einer Qt-basierten Anwendung auf einem Raspberry Pi 4 (CM) sind wir von der ZERO GmbH vor ein paar Tagen auf ein kurioses Problem gestoßen: Die Anwendung beinhaltet zwei Anwendungsfenster - ein QT Quick Fenster und ein weiteres Fenster, das mittels WebEngine (Chromium) eine Webanwendung darstellt. Die Inhalte in beiden Fenstern wurden während des Debuggins und beim manuellen Starten der Binärdatei aus der Kommandozeile heraus flüssig dargestellt. Bei Animationen und Mausbewegungen konnten wir keine bemerkenswerten Ruckler feststellen.&lt;/p>
&lt;p>Doch nach einem Start während des Boot-Prozesses durch ein Systemd Service-File sah die Sache schon ganz anders aus: Die Darstellung ruckelte stark und die CPU-Auslastung lag bereits bei einfachen Texteinblendungen bei ca 80 %.&lt;/p>
&lt;p>Wir konnten einen Zusammenhang zwischen dem Startzeitpunkt der Anwendung und der Performance feststellen. In frühen Bootphasen war die Performance schlecht - bei späterer Ausführung lief die Anwendung flüssig. Durch ein &amp;ldquo;sleep&amp;rdquo; Kommando in unserem Systemd Service File konnten wir den Zusammenhang verdeutlichen:&lt;/p>
&lt;pre tabindex="0">&lt;code>[Unit]
Description=App
[Service]
User=pi
Group=pi
Type=simple
ExecStart=/bin/bash -c &amp;#39;sleep 10; /opt/myapp/myapp -platform=eglfs&amp;#39;
[Install]
WantedBy=multi-user.target
&lt;/code>&lt;/pre>&lt;p>Alleine schon eine Verzögerung der Ausführung um 10 Sekunden führte zum gewünschten Ergebnis. Dies war jedoch keine Zufriedenstellende Lösung - schließlich wollten wir die Qt-Anwendung so schnell wie möglich starten und nicht unnötig Zeit verlieren, ohne den Grund für das Verhalten zu kennen.&lt;/p>
&lt;p>Ein Blick in das Systemlog offenbarte schließlich, dass unsere Anwendung den LLVMpipe Rasterizer nutze, wenn sie über ein Service-File gestartet wurde:&lt;/p>
&lt;pre tabindex="0">&lt;code>&amp;#34;Feb 03 04:33:29 raspberrypi bash[470]: Running on a software rasterizer (LLVMpipe), expect limited performance.&amp;#34;
&lt;/code>&lt;/pre>&lt;p>Letztendlich konnten wir das Performanceproblem nach einigen Websuchen durch ein Hinzufügen unseres &lt;code>pi&lt;/code> Benutzers zur Benutzergruppe &lt;code>render&lt;/code> (und einen Anschließenden Neustart) beheben:&lt;/p>
&lt;pre tabindex="0">&lt;code>sudo usermod -aG render pi
&lt;/code>&lt;/pre>&lt;p>Nach &lt;a href="https://www.hardwareluxx.de/community/threads/raspberry-pi-os-und-ein-paar-fehler-beim-%C3%B6ffnen-eines-programmes.1272595/post-27563953">Aussage des Forennutzers &lt;em>&amp;ldquo;cRaZy-biScuiT&amp;rdquo;&lt;/em>&lt;/a> wird damit ein Bug behoben, der dafür sorgt, dass Anwendungen unter dem &lt;code>pi&lt;/code> User keine hardwarebeschleunigten Anwendungen ausführen können.&lt;/p>
&lt;p>Unsere Qt-Anwendung startete nun auch schon in früheren Bootphasen inkl. Hardwareunterstützung und die Performance war wie erwartet.&lt;/p>
&lt;p>Bisher können wir allerdings nicht erklären, wieso das Problem zu späteren Startzeitpunkten nicht auftrat. Wir vermuten eine externe Beeinflussung evtl. durch später startende, dritte Anwendungen, die dafür sorgte, dass die Hardwarebeschleunigung zu diesen Zeitpunkten dennoch zur Verfügung stand.&lt;/p></description></item><item><title>Qt 5.15.2 mit WebEngine (Chromium) bauen - RAM-Verbrauch begrenzen</title><link>https://blog.zero-iee.com/posts/qt-5.15.2-mit-webengine-ram-begrenzen/</link><pubDate>Wed, 11 Jan 2023 14:19:06 +0100</pubDate><guid>https://blog.zero-iee.com/posts/qt-5.15.2-mit-webengine-ram-begrenzen/</guid><description>&lt;p>Beim Kompilieren von Qt 5.15.2 aus den offiziellen Open Source Quellen sind wir in Kombination mit unserem Buildserver auf ein Problem getoßen: Der Buildprozess wurde beim Kompilieren der Chromium-basierten &amp;ldquo;WebEngine&amp;rdquo; Komponente mit zunächst mysteriösen Fehlermeldungen unterbrochen. Ein Blick in das Kernellog mittels &lt;code>dmesg -w&lt;/code> offenbarte dann schnell, dass der sog. OOM-Killer des Linux-Kernels zugeschlagen hatte. Offenbar war der RAM-Verbrauch des Buildprozesses so speicherintensiv, dass der Prozess abgebrochen werden musste, um das Betriebssystem lauffähig zu halten.&lt;/p>
&lt;p>Doch wie konnte das sein? Unser Buildserver verfügt über 32 GB RAM und 24 CPU-Kerne. Eine durchaus leistungsstarke Machine. Sie sollte eigentlich nicht so schnell an Leistungsgrenzen kommen.&lt;/p>
&lt;p>Das Problem wird durch zwei Faktoren verursacht. Zum einen ist das Bauen der Chromium Browser-Engine extrem speicherintensiv. Generell werden &lt;a href="https://chromium.googlesource.com/chromium/src/+/main/docs/linux/build_instructions.md">nicht weniger als 16 GB RAM empfohlen&lt;/a>. In unserem Fall kommt aber noch ein weiteres Problem hinzu: Per default erstellt &amp;ldquo;Ninja&amp;rdquo; - das in Chromium eingesetzte Buildsystem - für jeden verfügbaren virtuellen CPU Core einen Build-Thread, damit der Buildprozess maximal parallelisiert wird. Was für einen haushaltsüblichen PC mit 16 GB RAM noch gut funktionieren mag, zwingt unseren Buildserver mit seinen 24 Cores allerdings in die Knie. Jeder einzelne Thread braucht eine nicht zu unterschätzende Menge RAM. Am Ende stimmt bei unserem Server das Verhältnis aus CPU-Cores und verfügbarem RAM nicht mehr, sodass der Buildvorgang abbricht.&lt;/p>
&lt;p>Das Problem lässt sich verhindern, wenn wir die Anzahl der zu nutzenden Ninja-Threads künstlich verkleinern - wenn wir also nicht mit 24 CPU-Kernen bauen, sondern beispielsweise nur mit 18.&lt;/p>
&lt;p>Dazu kann vor einem &lt;code>make -j$(nproc)&lt;/code> die Umgebungsvariable &lt;code>NINJAJOBS&lt;/code> gesetzt werden. Anders, als man vielleicht vermuten würde &lt;em>(und anders, als es im &lt;a href="https://www.linuxfromscratch.org/blfs/view/svn/x/qtwebengine.html">LFS-Handbuch&lt;/a> beschrieben wird)&lt;/em>, wird hier allerdings nicht einfach nur eine Zahl hinterlegt, sondern der vollständige &lt;code>-j&lt;/code> &lt;a href="https://manpages.debian.org/testing/ninja-build/ninja.1.en.html">Parameter von Ninja&lt;/a>:&lt;/p>
&lt;pre>&lt;code>export NINJAJOBS=&amp;quot;-j16&amp;quot;
&lt;/code>&lt;/pre>
&lt;p>Wird darauf folgend ein &lt;code>make&lt;/code> ausgeführt, werden die üblichen Qt Komponenten mit allen Cores kompiliert, während die Ninja-basierten Anteile (in diesem Fall Chromium als Teil der WebEngine) mit weniger CPU Kernen gebaut werden, um den RAM zu schonen.&lt;/p>
&lt;p>Für unsere Kombination von 32 GB RAM und 24 CPU Cores haben wir experimentell eine Anzahl von 16 Kernel ermittelt, mit denen unser Buildprozess noch durchläuft. Mit nur 8 CPU-Kernen hatte die RAM-Auslastung bei ca 12 GB ihren Peak.&lt;/p></description></item></channel></rss>