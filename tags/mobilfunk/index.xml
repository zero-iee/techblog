<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>mobilfunk on ZERO GmbH Tech Blog</title><link>https://blog.zero-iee.com/tags/mobilfunk/</link><description>ZERO GmbH Tech Blog (mobilfunk)</description><generator>Hugo -- gohugo.io</generator><language>de</language><lastBuildDate>Wed, 17 Jan 2024 10:00:00 +0100</lastBuildDate><atom:link href="https://blog.zero-iee.com/tags/mobilfunk/index.xml" rel="self" type="application/rss+xml"/><item><title>Raspberry Pi mit Waveshare NB-IoT HAT / Simcom SIM7070G Modem zum Internet verbinden</title><link>https://blog.zero-iee.com/posts/nb-iot-internet-connection-with-simcom-sim7070g-modem/</link><pubDate>Wed, 17 Jan 2024 10:00:00 +0100</pubDate><guid>https://blog.zero-iee.com/posts/nb-iot-internet-connection-with-simcom-sim7070g-modem/</guid><description>&lt;p>Wir haben uns das &amp;ldquo;Waveshare SIM7070G Cat-M/NB-IoT/GPRS HAT&amp;rdquo; für das Raspberry Pi genauer angesehen und in Betrieb genommen. Dabei haben wir verschiedene Fallstricke aufgedeckt und beschreiben im Folgenden, wie wir das NB-IoT Modem eingerichtet haben, um einen unserer &lt;a href="https://www.zero-iee.com/de/products/">#AMPS Nodes&lt;/a> mit dem Internet zu verbinden.&lt;/p>
&lt;ul>
&lt;li>Hardware:
&lt;ul>
&lt;li>Raspberry Pi 4 B&lt;/li>
&lt;li>Mobilfunk-HAT: &lt;a href="https://www.waveshare.com/wiki/SIM7070G_Cat-M/NB-IoT/GPRS_HAT">Waveshare SIM7070G Cat-M/NB-IoT/GPRS HAT&lt;/a>&lt;/li>
&lt;li>SIM-Karte: Telekom M2M&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Software: Raspbian 12 &amp;ldquo;Bookworm&amp;rdquo;&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="images/waveshare-raspi.webp" alt="Animated Webp Image of the blinking Waveshare module attached to a Raspi">&lt;/p>
&lt;h2 id="modem-an-raspberry-pi-anschließen" >Modem an Raspberry Pi anschließen
&lt;span>
&lt;a href="#modem-an-raspberry-pi-anschlie%c3%9fen">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;p>Das Modem wird - wie jedes andere HAT-Modul über den Raspberry Pin-Header mit dem Raspberry Pi 4 B verbunden. Zusätzlich haben wir das Modul über das mitgelieferte USB-Kabel mit dem Raspberry Pi verbunden, um in einem ersten Schritt zu überprüfen, ob die serielle Konsole wie erwartet funktioniert.&lt;/p>
&lt;p>&lt;em>Auf das USB-Kabel kann später verzichtet werden!&lt;/em>&lt;/p>
&lt;h2 id="das-modem-mit-strom-versorgen" >Das Modem mit Strom versorgen
&lt;span>
&lt;a href="#das-modem-mit-strom-versorgen">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;p>Offenbar ist das Mobilfunkmodem zu einem der GPIO Pins des Raspberry Pis verbunden. Indem der GPIO Pin 4 angesteuert wird, wird das Modem ein- oder ausgeschaltet. Nach dem Start sollte der Pin erst einmal auf einen Low-Pegel geschaltet werden, sodass (bedingt durch einen NPN-Transistor am Modul) am SimCom Modem ein High-Pegel anliegt. Der High-Pegel sollte am Eingang dauerhaft anliegen, wenn &lt;em>keine&lt;/em> Aktion gewünscht wird. Wird hingegen eine Ein- oder Ausschaltaktion gewünscht, muss an dem SimCom Modem mindestens für eine Sekunde (einschalten) bzw. 1,2 Sekunden (ausschalten) ein Low-Pegel anliegen, bevor zurück auf einen High-Pegel gewechselt wird.&lt;/p>
&lt;p>Das initiale Schalten auf den High-Pegel kann so durchgeführt werden:&lt;/p>
&lt;pre>&lt;code>echo &amp;quot;4&amp;quot; &amp;gt; /sys/class/gpio/export
sleep 0.1
echo &amp;quot;out&amp;quot; &amp;gt; /sys/class/gpio/gpio4/direction
echo &amp;quot;0&amp;quot; &amp;gt; /sys/class/gpio/gpio4/value
&lt;/code>&lt;/pre>
&lt;p>&lt;em>Erinnerung: &amp;ldquo;0&amp;rdquo; bewirkt einen Low-Pegel am NPN-Transistor und daher einen invertierten Pegel &amp;ldquo;high&amp;rdquo; am Modem!&lt;/em>&lt;/p>
&lt;p>Diese Kommandofolge wird in die Datei &lt;code>/etc/rc.local&lt;/code> vor die &lt;code>exit 0&lt;/code> Anweisung gepackt und somit nach jedem Boot einmal ausgeführt. Standardmäßig sollte das Modem nach der Versorgung mit Strom starten.&lt;/p>
&lt;p>Wenn das Modem explizit ein- oder ausgeschaltet werden soll, muss der Eingang - wie bereits erwähnt - am Modem für mindestens 1.2 Sekunden auf einen Low-Pegel gezogen werden. Das erreichen wir durch einen kurzen High-Pegel an den Moduleingängen.&lt;/p>
&lt;p>Zum Umschalten der Stromversorgung legen wir ein Script &lt;code>/home/pi/powertoggle.sh&lt;/code> an, das die folgende Sequenz als Inhalt hat:&lt;/p>
&lt;pre tabindex="0">&lt;code>#!/bin/bash
echo &amp;#34;1&amp;#34; &amp;gt; /sys/class/gpio/gpio4/value
sleep 1.2
echo &amp;#34;0&amp;#34; &amp;gt; /sys/class/gpio/gpio4/value
&lt;/code>&lt;/pre>&lt;p>Wird das Script 1x ausgeführt, startet das Modem. Wird es nochmal ausgeführt, wird es heruntergefahren.&lt;/p>
&lt;p>Normalerweise muss dieses &lt;code>powertoggle.sh&lt;/code> Script nach dem Start nicht ausgeführt werden, da das Modem von sich aus startet. Sollte allerdings keine serielle Verbindung zustande kommen, kann es helfen, die Stromversorgung einmal umzuschalten, indem das Script ausgeführt wird.&lt;/p>
&lt;h2 id="serielle-verbindung-zum-modem-prüfen" >Serielle Verbindung zum Modem prüfen
&lt;span>
&lt;a href="#serielle-verbindung-zum-modem-pr%c3%bcfen">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;p>Die Kommunikation mit dem Mobilfunkmodem läuft ausschließlich über eine serielle Verbindung, welche innerhalb von USB bereitgestellt wird. Die Bandbreite der Schnittstelle ist sehr begrenzt, aber im NB-IoT Anwendungsfall völlig ausreichend, denn die zur Verfügung stehende Bandbreite im Mobilfunknetz ist ohnehin minimal und eignet sich nur zur Übermittlung kleinster Datenmengen (Statusinformationen, Sensordaten, Kommandos, &amp;hellip;).&lt;/p>
&lt;p>Unser Modem identifiziert sich am USB-Port mit USB Vendor ID &lt;code>1e0e&lt;/code> und Product ID &lt;code>9206&lt;/code>:&lt;/p>
&lt;pre tabindex="0">&lt;code>pi@raspberrypi:~ $ lsusb
Bus 002 Device 001: ID 1d6b:0003 Linux Foundation 3.0 root hub
Bus 001 Device 020: ID 1e0e:9206 Qualcomm / Option SimTech SIM7080 &amp;lt;------ SIM7070 Modem
Bus 001 Device 002: ID 2109:3431 VIA Labs, Inc. Hub
Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub
&lt;/code>&lt;/pre>&lt;p>Laut Datenblatt (&lt;a href="https://www.simcom.com/product/SIM7070G.html">SIM7070_SIM7080_SIM7090 Series_Linux_Application Note_V1.02&lt;/a>) bietet das Modem über USB also folgende Schnittstellen an:&lt;/p>
&lt;ul>
&lt;li>0: (USB serial): Diagnostic interface&lt;/li>
&lt;li>1: (USB serial): GPS NMEA interface&lt;/li>
&lt;li>2: (USB serial): AT port interface&lt;/li>
&lt;li>3: (USB serial): QFLOG interface&lt;/li>
&lt;li>4: (USB serial): DAM interface&lt;/li>
&lt;li>5: (USB serial): Modem port interface&lt;/li>
&lt;/ul>
&lt;p>Je nach Product ID kann sich die Portzuordnung unterscheiden - ein Blick ins Datenblatt kann sich daher lohnen. Allerdings befindet sich die für diesen Artikel wichtigste Schnittstelle immer an Position 2: Die AT-Port Schnittstelle.&lt;/p>
&lt;p>Wie im Mobilfunkbereich üblich, wird auch dieses Mobilfunkmodem über sog. AT-Kommandos auf einer serielle Schnittstelle angesteuert. Der Linux Kernel ab Mainline Kernel 5.8.10 enthält die &lt;a href="https://elixir.bootlin.com/linux/v5.8.10/source/drivers/usb/serial/option.c#L1827">notwendigen Anpassungen&lt;/a> im USB Options Treiber, welcher die zuvor erwähnten seriellen Schnittstellen über USB bereitstellt.&lt;/p>
&lt;p>Um die AT-Schnittstelle zu testen, genügt es, mittels Minicom eine Verbindung herzustellen. Dazu wird Minicom installiert:&lt;/p>
&lt;pre>&lt;code>sudo apt install minicom
&lt;/code>&lt;/pre>
&lt;p>&amp;hellip; und gestartet:&lt;/p>
&lt;pre>&lt;code>sudo minicom -b 115200 -D /dev/ttyUSB2
&lt;/code>&lt;/pre>
&lt;p>Danach kann über die Eingabe von&lt;/p>
&lt;pre>&lt;code>AT
&lt;/code>&lt;/pre>
&lt;p>geprüft werden, ob AT-Kommandos akzeptiert werden. So stellen wir sicher, dass wir mit der korrekten Konsole sprechen. Kommt ein &amp;ldquo;OK&amp;rdquo; zurück, ist alles in Ordnung und das Modem reagiert auf unsere Kommandos.&lt;/p>
&lt;p>Über &lt;code>STRG+A&lt;/code> und &lt;code>X&lt;/code> kann Minicom wieder verlassen werden.&lt;/p>
&lt;h2 id="auf-das-raspberry-pi-eigene-serial-interface-umstellen" >Auf das Raspberry Pi-eigene Serial Interface umstellen
&lt;span>
&lt;a href="#auf-das-raspberry-pi-eigene-serial-interface-umstellen">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;p>Wenn wir sicher sind, dass die USB-basierte serielle Kommunikation mit dem Modem funktioniert, können wir auch auf das Raspberry Pi-eigene Serial Interface &lt;code>ttyS0&lt;/code> umstellen. Das bietet den großen Vorteil, dass keine USB-Verbindung mehr zwischen Raspi und dem Waveshare-Modul bestehen muss: Das USB-Kabel kann entfernt werden.&lt;/p>
&lt;p>Auf dem Raspberry Pi muss die serielle Konsole noch aktiviert und passend eingestellt werden.
Dazu im &lt;code>raspi-config&lt;/code> Tool &amp;ldquo;03 Interface options&amp;rdquo; und dann &amp;ldquo;I5 Serial Port&amp;rdquo; wählen. Einstellungen:&lt;/p>
&lt;ul>
&lt;li>Login Shell: NO&lt;/li>
&lt;li>Serial Port Hardware enabled: YES&lt;/li>
&lt;/ul>
&lt;p>Wichtig: Bei &amp;ldquo;Login shell&amp;rdquo; muss &lt;code>NO&lt;/code> gewählt werden. Andernfalls können Kommunikationsprobleme mit dem Modem auftreten. Zum Schluss das Raspi einmal neu starten, um die Einstellungen zu aktivieren.&lt;/p>
&lt;p>Von nun an sollte auch eine serielle Kommunikation über die &lt;code>/dev/ttyS0&lt;/code> Schnittstelle möglich sein. Wie im Fall oben kann erneut Minicom genutzt werden, um die Verbindung zu überprüfen.&lt;/p>
&lt;p>Tipp: Erscheint nicht sofort eine Antwort auf den &amp;ldquo;AT&amp;rdquo; Befehl, kann eine erneute Eingabe zum Erfolg führen. Dazu mehr im Abschnitt &lt;em>&amp;ldquo;Modem regiert nicht: Ein Auto Bauding-Problem&amp;rdquo;&lt;/em>.&lt;/p>
&lt;h2 id="mit-ppp-einen-ip-datenkanal-öffnen" >Mit PPP einen IP-Datenkanal öffnen
&lt;span>
&lt;a href="#mit-ppp-einen-ip-datenkanal-%c3%b6ffnen">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;p>Um eine IP-Adresse vom Mobilfunkprovider zu bekommen, muss eine PPP-Anmeldung durchgeführt werden. Wir nutzen eine Telekom M2M (Machine-to-Machine) SIM Karte, welche das Telekom NB-IoT Netz unterstützt. Die PPP-Informationen, die im folgenden genannt werden, passen auf das M2M Netz der Telekom und möglicherweise auch auf das einiger Reseller. Für andere Anbieter müssen APN oder evtl. auch mehr Konfigurationsparameter angepasst werden.&lt;/p>
&lt;p>Die PPP-Verbindung stellen wir über den PPP Daemon &lt;code>pppd&lt;/code> her, der wie folgt installiert wird:&lt;/p>
&lt;pre>&lt;code>sudo apt install ppp
&lt;/code>&lt;/pre>
&lt;p>An zwei Stellen muss der PPP Daemon konfiguriert werden. Beginnen wir mit der Providerkonfiguration, die in &lt;code>/etc/ppp/peers/telekomM2M&lt;/code> angelegt wird:&lt;/p>
&lt;pre tabindex="0">&lt;code>user &amp;#34;m2m&amp;#34;
connect &amp;#34;/usr/sbin/chat -v -f /etc/chatscripts/telekomM2M -T internet.m2mportal.de&amp;#34;
# Serial device to which the modem is connected.
/dev/ttyS0
# Speed of the serial line.
115200
nocrtscts
debug
nodetach
ipcp-accept-local
ipcp-accept-remote
# Assumes that your IP address is allocated dynamically by the ISP.
noipdefault
# Try to get the name server addresses from the ISP.
usepeerdns
# Use this connection as the default route.
defaultroute
# Makes pppd &amp;#34;dial again&amp;#34; when the connection is lost.
persist
maxfail 0
holdoff 5
# Do not ask the remote to authenticate.
noauth
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>&lt;code>/etc/chatscripts/telekomM2M&lt;/code> ist der Name des &amp;ldquo;Chat-Scripts&amp;rdquo; für die Kommunikation mit dem Modem&lt;/li>
&lt;li>&lt;code>internet.m2mportal.de&lt;/code> ist der APN-Name des M2M-Netzwerks&lt;/li>
&lt;/ul>
&lt;p>Da das Chat-Script &lt;code>/etc/chatscripts/telekomM2M&lt;/code> noch nicht existiert, wird es nun angelegt:&lt;/p>
&lt;pre tabindex="0">&lt;code>ABORT &amp;#34;BUSY&amp;#34;
ABORT &amp;#34;VOICE&amp;#34;
ABORT &amp;#34;NO CARRIER&amp;#34;
ABORT &amp;#34;NO DIALTONE&amp;#34;
ABORT &amp;#34;NO DIAL TONE&amp;#34;
ABORT &amp;#34;NO ANSWER&amp;#34;
ABORT &amp;#34;DELAYED&amp;#34;
ABORT &amp;#34;ERROR&amp;#34;
TIMEOUT 5
&amp;#39;&amp;#39; AT
&amp;#39;OK&amp;#39; AT
OK ATE1
OK AT+CGDCONT=1,&amp;#34;IPV4V6&amp;#34;,&amp;#34;\T&amp;#34;,&amp;#34;&amp;#34;,0,0
OK ATD*99#
TIMEOUT 22
CONNECT &amp;#39;&amp;#39;
&lt;/code>&lt;/pre>&lt;p>Wie auch bei der vorherigen Konfigurationsdatei: Dieses Chat-Script funktioniert möglicherweise nur für das &amp;ldquo;Telekom M2M&amp;rdquo; Netz der Deutschen Telekom. Ob es so oder so ähnlich auch für andere Anbieter funktioniert, können wir derzeit nicht sicher sagen. Womöglich kann es aber auch für andere Provider wie z.B. Vodafone eingesetzt werden.&lt;/p>
&lt;p>&lt;em>Übrigens: Wie haben in dieses Script eine zweite &amp;ldquo;AT&amp;rdquo; Abfrage eingebaut, um ein Timing-Problem zu vermeiden. Dazu später mehr unter &amp;ldquo;Ein Timing-Problem&amp;rdquo;.&lt;/em>&lt;/p>
&lt;p>Nun, da beide Konfigurationsdateien fertiggestellt sind, können wir das Modem zum Leben erwecken. Stellt sicher, dass die serielle Konsole &lt;code>/dev/ttyS0&lt;/code> nicht mehr von Minicom oder einem ähnlichen Terminal verwendet wird und führt folgendes Kommando auf dem Raspberry Pi aus:&lt;/p>
&lt;pre>&lt;code>sudo pppd call telekomM2M
&lt;/code>&lt;/pre>
&lt;p>Der PPP Daemon versucht nun, sich am Netzwerk anzumelden. Hat er Erfolg, bezieht er vom PPP Server eine IP-Adresse und andere Informationen über eine mobile Datenverbindung. Eine neue Netzwerkschnittstelle &lt;code>ppp0&lt;/code> wird im Hintergrund eingerichtet. In einem zweiten Konsolenfenster kann dies nachvollzogen werden:&lt;/p>
&lt;pre tabindex="0">&lt;code>pi@raspberrypi:~ $ ip addr
[...]
22: ppp0: &amp;lt;POINTOPOINT,MULTICAST,NOARP,UP,LOWER_UP&amp;gt; mtu 1500 qdisc pfifo_fast state UNKNOWN group default qlen 3
link/ppp
inet 10.155.22.50 peer 10.64.64.64/32 scope global ppp0
valid_lft forever preferred_lft forever
&lt;/code>&lt;/pre>&lt;p>Die (private) IP-Adresse &lt;code>10.155.22.50&lt;/code> liegt am Interface an und kann ab sofort für die Kommunikation zu anderen Netzwerkteilnehmern oder ins Internet verwendet werden:&lt;/p>
&lt;pre>&lt;code>ping -I ppp0 1.1.1.1
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>Falls nicht sofort Pings durchkommen: Keine Sorge!&lt;/strong> Das NB-IoT M2M Netz ist nicht auf Latenz optimiert. An unserem Standort dauert es ca. 7 Sekunden, bis die ersten Datenpakete zurückgekommen sind. Mit jedem Datenpaket wird die Latenz dann langsam besser, bis wir uns gut 100 ms annähern.&lt;/p>
&lt;pre tabindex="0">&lt;code>pi@raspberrypi:~ $ ping -I ppp0 1.1.1.1
PING 1.1.1.1 (1.1.1.1) from 10.155.22.50 ppp0: 56(84) bytes of data.
64 bytes from 1.1.1.1: icmp_seq=2 ttl=51 time=7002 ms
64 bytes from 1.1.1.1: icmp_seq=3 ttl=51 time=5978 ms
64 bytes from 1.1.1.1: icmp_seq=4 ttl=51 time=5337 ms
64 bytes from 1.1.1.1: icmp_seq=5 ttl=51 time=4313 ms
64 bytes from 1.1.1.1: icmp_seq=8 ttl=51 time=2297 ms
64 bytes from 1.1.1.1: icmp_seq=9 ttl=51 time=2316 ms
64 bytes from 1.1.1.1: icmp_seq=10 ttl=51 time=1315 ms
64 bytes from 1.1.1.1: icmp_seq=11 ttl=51 time=433 ms
64 bytes from 1.1.1.1: icmp_seq=12 ttl=51 time=392 ms
64 bytes from 1.1.1.1: icmp_seq=13 ttl=51 time=393 ms
64 bytes from 1.1.1.1: icmp_seq=14 ttl=51 time=231 ms
64 bytes from 1.1.1.1: icmp_seq=15 ttl=51 time=429 ms
64 bytes from 1.1.1.1: icmp_seq=16 ttl=51 time=268 ms
64 bytes from 1.1.1.1: icmp_seq=17 ttl=51 time=347 ms
64 bytes from 1.1.1.1: icmp_seq=18 ttl=51 time=546 ms
64 bytes from 1.1.1.1: icmp_seq=19 ttl=51 time=163 ms
64 bytes from 1.1.1.1: icmp_seq=20 ttl=51 time=282 ms
64 bytes from 1.1.1.1: icmp_seq=21 ttl=51 time=283 ms
64 bytes from 1.1.1.1: icmp_seq=22 ttl=51 time=139 ms
64 bytes from 1.1.1.1: icmp_seq=23 ttl=51 time=116 ms
64 bytes from 1.1.1.1: icmp_seq=24 ttl=51 time=135 ms
64 bytes from 1.1.1.1: icmp_seq=25 ttl=51 time=154 ms
64 bytes from 1.1.1.1: icmp_seq=26 ttl=51 time=173 ms
^C
--- 1.1.1.1 ping statistics ---
27 packets transmitted, 23 received, 14.8148% packet loss, time 26180ms
rtt min/avg/max/mdev = 116.182/1436.578/7001.561/2066.895 ms, pipe 7
&lt;/code>&lt;/pre>&lt;p>In der &lt;code>/etc/resolv.conf&lt;/code> sind die beiden vom PPP-Daemon bezogenen DNS-Server aufgelistet:&lt;/p>
&lt;pre tabindex="0">&lt;code>pi@raspberrypi:~ $ cat /etc/resolv.conf
nameserver 10.74.210.210
nameserver 10.74.210.211
&lt;/code>&lt;/pre>&lt;p>Somit ist auch eine Namensauflösung über Telekom DNS-Server verfügbar.&lt;/p>
&lt;p>Informationen wie zugeordnete IP-Adresse, DNS-Server und Gateway (&amp;ldquo;remote IP address&amp;rdquo;) werden außerdem in die ppp Daemon Logausgabe geschrieben:&lt;/p>
&lt;pre tabindex="0">&lt;code>[...]
local IP address 10.155.22.50
remote IP address 10.64.64.64
primary DNS address 10.74.210.210
secondary DNS address 10.74.210.211
[...]
&lt;/code>&lt;/pre>&lt;p>&amp;hellip; was leider nicht für die öffentliche IPv6 Adresse gilt, die dem Modem zugeteilt wird: Diese findet sich nur in der Ausgabe von &lt;code>ip addr show dev ppp0&lt;/code> wieder. Dennoch ist IPv6 ebenso verfügbar:&lt;/p>
&lt;pre>&lt;code>ping -I ppp0 2001:4860:4860::8888
&lt;/code>&lt;/pre>
&lt;p>Wer nun das M2M Netzwerk für seinen gesamten Internetverkehr verwenden will, kann die Default-Route darauf umstellen:&lt;/p>
&lt;pre tabindex="0">&lt;code>sudo ip route del default
sudo ip -6 route del default
sudo ip route add default via 10.64.64.64 dev ppp0
sudo ip -6 route add default via fe80::1:2:47b1:3706 dev ppp0
&lt;/code>&lt;/pre>&lt;p>Die IPv4-Gatewayadresse &lt;code>10.64.64.64&lt;/code> wurde dem ppp Log entnommen - das IPv6 Pendant &lt;code>fe80::1:2:47b1:3706&lt;/code> wurde den IPv6 Routinginformationen mittels &lt;code>ip -6 route&lt;/code> entnommen.&lt;/p>
&lt;p>&lt;strong>Übrigens&lt;/strong>: der PPP-Daemon scheint relativ rücksichtlos mit den Resolvereinträgen in &lt;code>/etc/resolv.conf&lt;/code> umzugehen und überschreibt einfach vorhandene Einträge. Belässt man die Standardroute beispielsweise auf dem Ethernet-Interface, kann es sein, dass kein DNS-Resolver mehr erreichbar ist und Namensauflösungen fehlschlagen. Eine nachträgliche Korrektur der &lt;code>resolv.conf&lt;/code> schafft in diesem Fall Abhilfe.&lt;/p>
&lt;h2 id="autostart-für-den-ppp-daemon" >Autostart für den PPP Daemon
&lt;span>
&lt;a href="#autostart-f%c3%bcr-den-ppp-daemon">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;p>Standardmäßig bringt das ppp-Paket in Debian keinen Systemd Service für den PPP Daemon mit - aber kein Problem! Die Paketmaintainer von Arch Linux haben ein passendes &lt;a href="https://gitlab.archlinux.org/archlinux/packaging/packages/ppp/-/blob/main/ppp.systemd?ref_type=heads">Service-File erstellt&lt;/a>:&lt;/p>
&lt;pre tabindex="0">&lt;code>[Unit]
Description=PPP link to %I
Before=network.target
[Service]
Type=notify
ExecStart=/usr/sbin/pppd call %I nodetach nolog up_sdnotify
[Install]
WantedBy=multi-user.target
&lt;/code>&lt;/pre>&lt;p>Dieses können wir unter &lt;code>/etc/systemd/system/ppp@.service&lt;/code> speichern und den Daemon in den Boot-Autostart aufnehmen:&lt;/p>
&lt;pre>&lt;code>sudo systemctl daemon-reload
sudo systemctl enable ppp@telekomM2M.service
&lt;/code>&lt;/pre>
&lt;p>&lt;code>telekomM2M&lt;/code> ist hier der Name der Datei &lt;code>/etc/ppp/peers/telekomM2M&lt;/code>. Der Teil muss entsprechend angepasst werden, wenn die PP Konfigurationsdatei anders benannt ist. Dementsprechend ließe sich bei der Verwendung mehrerer Provider-Configs beispielsweise auch ein &lt;code>sudo systemctl enable ppp@provider2.service&lt;/code> aufrufen.&lt;/p>
&lt;p>Der PPP Daemon kann selbstverständlich auch über ein Systemd &amp;ldquo;start&amp;rdquo; Kommando gestartet werden:&lt;/p>
&lt;pre>&lt;code>sudo systemctl start ppp@telekomM2M.service
&lt;/code>&lt;/pre>
&lt;h2 id="modem-regiert-nicht-ein-auto-bauding-problem" >Modem regiert nicht: Ein Auto Bauding-Problem
&lt;span>
&lt;a href="#modem-regiert-nicht-ein-auto-bauding-problem">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;p>Während unserer Experimente mit Waveshare&amp;rsquo;s SIM7070G-basierten Mobilfunkmodul sind wir auf ein Timing-Problem gestoßen. Wir könnten es lösen, aber es war nicht trivial zu finden, daher wollen wir kurz darauf eingehen.&lt;/p>
&lt;h3 id="symptome" >Symptome
&lt;span>
&lt;a href="#symptome">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h3>&lt;p>Während der ersten Schritte mit dem Modul haben wir nicht das native serielle Interface genutzt, sondern sind den Umweg über den USB-to-Serial Adapter gegangen. Also Raspi =&amp;gt; USB-Anschluss des Moduls. Mit diesem Setup funktionierte der PPP-Daemon einwandfrei und wir konnten eine Internetverbindung herstellen.&lt;/p>
&lt;p>Später stellten wir auf die native serielle Verbindung um - also ohne den USB-Anschluss - und nutzten unter Linux statt &lt;code>/dev/ttyUSB2&lt;/code> das &lt;code>/dev/ttyS0&lt;/code> Interface, um die Kommunikation über den Raspi Header herzustellen. Allerdings konnte der PPP-Daemon ab diesem Zeitpunkt keine Verbindung mehr herstellen und brach mit einem Timeout ab.&lt;/p>
&lt;p>Unter einer Bedingung konnten wir das Modem in diesem Fall dennoch zur Kommunikation bewegen: Nämlich dann, wenn wir uns vor Ausführung des PPP-Daemons mit einer seriellen Konsole (z.B. Minicom) auf die Schnittstellen aufschalteten und einmal oder mehrmals das &amp;ldquo;AT&amp;rdquo; Kommando ausführen, um ein &amp;ldquo;OK&amp;rdquo; zurückzubekommen. Das Modem reagierte und bei einem erneuten Start des PPP-Daemons konnte schließlich auch eine Verbindung hergestellt werden. Das Aufschalten mit einem Terminal-Emulator schien also etwas an der Verbindung zurechtzurücken.&lt;/p>
&lt;h3 id="die-ursache" >Die Ursache
&lt;span>
&lt;a href="#die-ursache">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h3>&lt;p>Durch systematisches Ausprobieren und Fixieren der Baudrate am Modem konnten wir schließlich die Ursache finden: Das &amp;ldquo;Auto-Baud&amp;rdquo; Feature des Modems - allem Anschein nach in Verbindung mit einem Timing-Problem.&lt;/p>
&lt;p>Das Modem ist ab Werk so eingestellt, dass es keine fest definierte Baudrate akzeptiert, sondern so, dass es versucht, beim ersten &amp;ldquo;AT&amp;rdquo; Kommando die Baudrate selbst zu erkennen und zu setzen. Stellt man sein Minicom-Tool also beispielsweise auf eine Baudrate von 115200 ein und schaltet sich auf das serielle Interface auf, führt die Ausführung von &amp;ldquo;AT&amp;rdquo; dazu, dass sich das Modem ebenfalls auf 115200 Baud einstellt. Dies erklärt auch, wieso wir nach so einem Schritt den PPP-Daemon niemals dazu bewegen konnten, mit einer anderen Baudrate zu arbeiten. Die erste Verbindung und ihre Baudrate sind nach einem Absetzen von &amp;ldquo;AP&amp;rdquo; ausschlaggebend.&lt;/p>
&lt;p>Das erste, was das Modem von unserem Raspi mitbekommen musste, war also ein &amp;ldquo;AT&amp;rdquo; String, um seine eigene Baudrate passend konfigurieren zu können. Wir haben im nächsten Schritt unser Chat-Script geprüft und festgestellt, dass das erste Kommando tatsächlich ein &amp;ldquo;AT&amp;rdquo; Kommando war. Alles in Ordnung also?&lt;/p>
&lt;p>Nicht ganz. Wir haben schließlich herausgefunden, dass wir an der Stelle möglicherweise in ein Timingproblem laufen. Denn die Dokumentation zu einem anderen Mobilfunkmodul des gleichen Herstellers SimCom erwähnt zum Auto-Baud Feature, dass nach dem ersten &amp;ldquo;AT&amp;rdquo; eine Weile gewartet werden sollte, bevor weitere Kommandos abgesetzt werden. Andernfalls könnten folgende Kommandos evtl. nicht mehr korrekt interpretiert werden.&lt;/p>
&lt;h3 id="die-lösung" >Die Lösung
&lt;span>
&lt;a href="#die-l%c3%b6sung">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h3>&lt;p>Da die ChatScript Syntax keinen &amp;ldquo;sleep&amp;rdquo; Befehl oder ähnliches zu kennen scheint, haben wir kurzerhand eine zweite &amp;ldquo;AT&amp;rdquo; Abfrage hinzugefügt, um durch diese etwas Zeit zu gewinnen.&lt;/p>
&lt;pre tabindex="0">&lt;code>&amp;#39;&amp;#39; AT
&amp;#39;OK&amp;#39; AT
&lt;/code>&lt;/pre>&lt;p>Und tatsächlich - nun konnten wir auch über die native Serial-Schnittstelle mit dem Modem kommunizieren - ganz ohne vorheriges Aufschalten via Minicom. Der PPP-Daemon lief direkt nach dem Boot.&lt;/p>
&lt;p>Wieso hat es aber über die USB-Serial Verbindung tadellos funktioniert? Wir vermuten, dass die Umwandlung von und zu USB genug Verzögerung im System verursacht, sodass das Timingproblem in diesem Fall nicht auftritt.&lt;/p>
&lt;h2 id="eine-bessere-lösung-für-das-power-management" >Eine bessere Lösung für das Power Management
&lt;span>
&lt;a href="#eine-bessere-l%c3%b6sung-f%c3%bcr-das-power-management">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;p>Zu Beginn dieses Beitrags haben wir bereits beschrieben, dass sich das SIM7070G Modul über GPIO4 des Raspberry Pis ein- oder ausschalten lässt. Dabei haben wir allerdings unterschlagen, dass wir den Pin in unserem &lt;code>powertoggle.sh&lt;/code> Script immer für eine Sekunde auf einen High-Pegel schalten (resultierend in einem Low-Pegel am SIM7070G-Modem).&lt;/p>
&lt;p>Tatsächlich offenbart das Datenblatt des Mobilfunkmodems folgendes:&lt;/p>
&lt;ul>
&lt;li>Low-Pegel für mindestens 1.0 Sekunde: Einschalten&lt;/li>
&lt;li>Low-Pegel für mindestens 1.2 Sekunden: Ausschalten.&lt;/li>
&lt;/ul>
&lt;p>Wir können also nicht nur &amp;ldquo;umschalten&amp;rdquo; und einen möglicherweise unbekannten Ausgangszustand in sein Gegenteil umkehren, sondern durch präzises Timing beim Schalten gezielt einen &amp;ldquo;An&amp;rdquo;- oder &amp;ldquo;Aus&amp;rdquo;-Zustand herbeiführen.&lt;/p>
&lt;p>Wir haben zunächst mit Bash-Befehlen experimentiert, aber relativ schnell festgestellt, dass das Timing der Bash-Shell zu ungenau ist, um zuverlässig ein- oder auszuschalten. Daher haben wir ein kleines Tool &lt;code>modemctl&lt;/code> in C implementiert, das &amp;ldquo;init&amp;rdquo;, &amp;ldquo;on&amp;rdquo; und &amp;ldquo;off&amp;rdquo; Argumente annehmen und den GPIO4 Ausgang des Raspis entsprechend präzise ansteuern kann:&lt;/p>
&lt;p>Quellcode &lt;code>modemctl.c&lt;/code>:&lt;/p>
&lt;pre tabindex="0">&lt;code>/*
* modemctl: Controls Waveshare NB-IoT power state by controlling GPIO pin
* Installing dependencies: sudo apt install pigpio
* Compiling: gcc -o modemctl modemctl.c -l pigpio
* Running: sudo ./modemctl init
* sudo ./modemctl on
* sudo ./modemctl off
*/
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;pigpio.h&amp;gt;
#define GPIO_PIN 4 // GPIO number of pin
#define ON_TIME 1.0 // Hold time for turning on
#define OFF_TIME 1.2 // Hold time for turning off
int main(int argc, char *argv[]) {
if (gpioInitialise() &amp;lt; 0) {
fprintf(stderr, &amp;#34;pigpio initialisation failed\n&amp;#34;);
return 1;
}
/* Set GPIO modes */
gpioSetMode(GPIO_PIN, PI_OUTPUT);
if (strcmp(argv[1], &amp;#34;init&amp;#34;) == 0) {
printf(&amp;#34;Initialising NB-IoT module power state\n&amp;#34;);
gpioWrite(GPIO_PIN, 0); /* Set pin to low to generate HIGH level on PWR input of module */
} else if (strcmp(argv[1], &amp;#34;on&amp;#34;) == 0) {
printf(&amp;#34;Turning NB-IoT module ON\n&amp;#34;);
gpioWrite(GPIO_PIN, 1); /* Set GPIO4 to 1 for ON_TIME seconds */
time_sleep(ON_TIME);
gpioWrite(GPIO_PIN, 0);
} else if (strcmp(argv[1], &amp;#34;off&amp;#34;) == 0) {
printf(&amp;#34;Turning NB-IoT module OFF\n&amp;#34;);
gpioWrite(GPIO_PIN, 1); /* Set GPIO4 to 1 for OFF_TIME seconds */
time_sleep(OFF_TIME);
gpioWrite(GPIO_PIN, 0);
} else {
printf(&amp;#34;Please provide \&amp;#34;on\&amp;#34; or \&amp;#34;off\&amp;#34; as an argument!\n&amp;#34;);
}
}
&lt;/code>&lt;/pre>&lt;p>Das Programm wird via&lt;/p>
&lt;pre>&lt;code>gcc -o modemctl modemctl.c -l pigpio
&lt;/code>&lt;/pre>
&lt;p>kompiliert und kann dann mit sudo gestartet werden, um das Modul zu schalten, z.B.&lt;/p>
&lt;pre>&lt;code>sudo ./modemctl init
sudo ./modemctl on
&lt;/code>&lt;/pre>
&lt;p>&amp;hellip; um das Modul einzuschalten.&lt;/p>
&lt;p>Zu beachten ist, dass das Ein- und Ausschalten des Modems einige Sekunden dauern kann und die serielle Schnittstelle nicht unmittelbar danach zur Verfügung steht.&lt;/p>
&lt;p>Am Blinken der &amp;ldquo;Net&amp;rdquo; LED am Modul kann das Status abgelesen werden:&lt;/p>
&lt;ul>
&lt;li>Kein Blinken: Ausgeschaltet&lt;/li>
&lt;li>Langsames Blinken: Eingeschaltet, aber keine PPP-Verbindung / Datenübertragung&lt;/li>
&lt;li>Schnelles Blinken (~ 800 Sekunden Zyklus): Eingeschaltet und Datenübertragung aktiv&lt;/li>
&lt;/ul>
&lt;p>Statt sich darauf zu verlassen, dass das Modem direkt nach dem Boot funktioniert &lt;em>- wir haben gegenteilige Erfahrungen gemacht -&lt;/em> können wir also anstelle des &lt;code>init.sh&lt;/code> Scriptes folgendes in die &lt;code>/etc/rc.local&lt;/code> aufnehmen:&lt;/p>
&lt;pre>&lt;code>/home/pi/modemctl init
/home/pi/modemctl on
&lt;/code>&lt;/pre>
&lt;p>Hiermit sollte das Modem beim Boot nun zuverlässig aktiviert werden. Das &lt;code>powertoggle.sh&lt;/code> Script wird nicht mehr benötigt.&lt;/p>
&lt;h2 id="performance" >Performance
&lt;span>
&lt;a href="#performance">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;p>Wie in dem vorher gezeigten ping-Output dargestellt, kann die Latenz der Netzwerkverbindung stark variieren. Wir haben an unserem Standort die Erfahrung gemacht, dass die Latenz zunächst bei einigen Sekunden liegt. Mit anhaltender Datenübertragung sinkt die Latenz aber auf knapp 200 ms. Selbstverständlich eignet sich die Verbindung daher nicht um Übertragen mittlerer oder größerer Datenmengen. Für unsere Anwendungsfälle ist die Verbindung allerdings völlig brauchbar:&lt;/p>
&lt;ul>
&lt;li>Rollout von Konfigurationsänderungen (SSH / Ansible)&lt;/li>
&lt;li>Übertragung von Statusinformationen&lt;/li>
&lt;li>Übertragung kleiner Firmwareupdates&lt;/li>
&lt;li>Remote-SSH-Login zum Debugging&lt;/li>
&lt;/ul>
&lt;p>gping Test:&lt;/p>
&lt;pre>&lt;code>gping -i ppp0 -s -n 1.0 -b 60 1.1.1.1
&lt;/code>&lt;/pre>
&lt;p>&lt;img src="images/gping.webp" alt="gping Test mit dem oben erwähnten Kommando: Graph zeigt Latenz über 60 Sekunden">&lt;/p>
&lt;p>Download-Test mit:&lt;/p>
&lt;pre>&lt;code>curl http://speedtest.tele2.net/1GB.zip -o /dev/null -m 60
&lt;/code>&lt;/pre>
&lt;p>Wir haben innerhalb eines Gebäudes und in Nähe eines Mobilfunkmasten 9,579 kByte/s (~77 kBit/s) im Download gemessen. Zeitspanne: 60 Sekunden.&lt;/p>
&lt;p>Upload-Test:&lt;/p>
&lt;pre>&lt;code>curl -T /dev/urandom http://speedtest.tele2.net/upload.php -O /dev/null -m 60
&lt;/code>&lt;/pre>
&lt;p>ähnliche bis leicht höhere Datenraten konnten wir auch im Upload erreichen. Allerdings ist uns wegen Verbindungsabbrüchen kein längerer, durchgängiger Upload-Vorgang gelungen. Die Aussagekraft des Tests ist daher zweifelhaft. Ursache für die Abbrüche ist möglicherweise eine Limitierung der zur Verfügung stehenden &amp;ldquo;Air Time&amp;rdquo; im NB-IoT Netz.&lt;/p>
&lt;p>Übrigens: Wer (ungeachtet der Latenz) lokal simulieren will, wie sich eine SSH-Session bei der von uns gemessenen Datenübertragungsrate &amp;ldquo;anfühlt&amp;rdquo;, kann dazu folgendes Kommando verwenden:&lt;/p>
&lt;pre>&lt;code>ssh -o ProxyCommand='pv -qL 9K | nc %h %p | pv -qL 9K' user@target-machine
&lt;/code>&lt;/pre>
&lt;p>Zusammenfassend lässt sich aber sagen, dass die Datenrate für die oben genannten Zwecke ausreichen ist. Dank &lt;a href="https://www.wireguard.com/">Wireguard&lt;/a>&amp;rsquo;s schlankem VPN Protokoll sind wir sogar in der Lage, verhältnismäßig latenzarme Verbindungen zu unserem &lt;a href="https://blog.zero-iee.com/posts/vpn-firewall-shorewall/">Management VPN&lt;/a> herzustellen. Wir sind gespannt, wie sich das System in ersten Feldversuchen schlagen wird.&lt;/p>
&lt;hr>
&lt;p>Quellen:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.waveshare.com/wiki/SIM7070G_Cat-M/NB-IoT/GPRS_HAT">Waveshare Wiki&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.waveshare.com/w/upload/3/39/SIM7080_Series_AT_Command_Manual_V1.02.pdf">SimCom AT Kommandoreferenz&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.waveshare.com/w/upload/4/47/SIM7080_Series_Linux_Application_Note_V1.00.pdf">SimCom Linux Application Note&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://tldp.org/HOWTO/PPP-HOWTO/x1219.html">ChatScript&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.digikey.jp/htmldatasheets/production/1833952/0/0/1/sim800-series-at-command-manual.html#pf12">Auto-Bouding explained in a SIM800 Series datasheet&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>Quectel RM520M und Telit FM990A28 5G Modem mit Raspberry Pi OS nutzen</title><link>https://blog.zero-iee.com/posts/quectel-rm520n-and-telit-fn990a28-5g-modems-on-raspberrypi-os/</link><pubDate>Wed, 31 May 2023 12:44:58 +0200</pubDate><guid>https://blog.zero-iee.com/posts/quectel-rm520n-and-telit-fn990a28-5g-modems-on-raspberrypi-os/</guid><description>&lt;p>Auf unserer Odyssee auf der Suche nach einem 5G Mobilfunkmodem haben wir mittlerweile einige Modems verschiedener Hersteller ausprobiert. Leider war die Inbetriebnahme nicht immer erfolgreich. Mal fehlte der Treibersupport im Linux-Kernel gänzlich - mal war die Ansteuerung via NetworkManager / ModemManager fehlerbehaftet oder überhaupt nicht möglich.&lt;/p>
&lt;p>Uns ist eine einfache Inbetriebnahme und ein stabiler Betrieb wichtig. Da wir die Modems nicht nur auf einigen wenigen Geräten einsetzen wollen, kommt für uns eine manuelle Anpassung des Linux-Kernels in der Regel nicht infrage. Zu groß ist der damit verbundene Aufwand und zu unübersichtlich sind die Folgen, die sich daraus für den weiteren Lebenszyklus eines Produkts ergeben. Daher soll das Betriebssystem - oftmals ein Raspberry Pi OS - möglichst im Werkszustand und ohne große Anpassungen genutzt werden.&lt;/p>
&lt;p>&lt;strong>Mittlerweile haben sich für uns zwei Modems herauskristallisiert, die in Kombination mit dem aktuellen &lt;a href="https://www.raspberrypi.com/software/operating-systems/">Raspberry Pi OS&lt;/a> auf Debian 11 &amp;ldquo;Bullseye&amp;rdquo; Basis (Kernel 6.1) &amp;ldquo;out of the box&amp;rdquo; funktionieren:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>&lt;a href="https://www.quectel.com/product/5g-rm520n-gl">Quectel RM520N&lt;/a>&lt;/strong>&lt;/li>
&lt;li>&lt;strong>&lt;a href="https://www.telit.com/devices/fn990axx/">Telit FM990A28&lt;/a>&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>beide 5G Modems unterstützen nicht nur das aktuell weit verbreitete &amp;ldquo;5G New Radio&amp;rdquo; mit LTE Control Plane (NSA), sondern auch 5G NR Standalone (SA), sodass bei einer entsprechenden Ausbaustufe des 5G Mobilfunknetzes auch von extrem niedrigeren Latenzen profitiert werden kann.&lt;/p>
&lt;h2 id="hardware-setup" >Hardware Setup
&lt;span>
&lt;a href="#hardware-setup">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;p>Unser Hardware-Setup für die Evaluierung beider Module sieht wie folgt aus:&lt;/p>
&lt;ul>
&lt;li>Raspberry Pi CM4&lt;/li>
&lt;li>&lt;a href="https://www.waveshare.com/wiki/CM4-DUAL-ETH-4G/5G-BASE">Waveshare Dual Ethernet IoT Base Board&lt;/a> (mit M.2 Slot)&lt;/li>
&lt;li>Telit FM990A28 M.2 Modul &lt;em>oder&lt;/em>&lt;/li>
&lt;li>Quectel RM520N&lt;/li>
&lt;li>IoT SIM-Karte der Deutschen Telekom&lt;/li>
&lt;/ul>
&lt;figure>&lt;img src="images/waveshare-board.jpg"/>&lt;figcaption>
&lt;h4>Waveshare Board mit Quectel 5G Modem&lt;/h4>
&lt;/figcaption>
&lt;/figure>
&lt;h2 id="inbetriebnahme" >Inbetriebnahme
&lt;span>
&lt;a href="#inbetriebnahme">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;p>Die Inbetriebnahme unseres Telit-Moduls lief wie folgt ab: &lt;em>(ähnlich für Quectel!)&lt;/em>&lt;/p>
&lt;p>Überprüfen der Sichtbarkeit des Moduls im USB Subsystem:&lt;/p>
&lt;pre>&lt;code>$ lsusb
&lt;/code>&lt;/pre>
&lt;p>Hier sollte ein Telit Device sichtbar sein:&lt;/p>
&lt;pre>&lt;code>[...]
Bus 002 Device 003: ID 1bc7:1070 Telit Wireless Solutions FN990
[...]
&lt;/code>&lt;/pre>
&lt;p>Auch der ModemManager sollte das Modul erkennen:&lt;/p>
&lt;pre>&lt;code>tom@raspberry:~ $ mmcli -L
/org/freedesktop/ModemManager1/Modem/0 [Telit] FN990A28
&lt;/code>&lt;/pre>
&lt;p>Mittels&lt;/p>
&lt;pre>&lt;code>mmcli -m 0
&lt;/code>&lt;/pre>
&lt;p>Können einige Details zum Modem ausgegeben werden - unter anderem, ob eine Verbindung zum Mobilfunknetz besteht, oder eine SIM-Karte zugeordnet ist.&lt;/p>
&lt;p>Bei unserem ersten Versuch wurde im &amp;ldquo;Status&amp;rdquo; Abschnitt ein rotes &lt;code>sim-missing&lt;/code> angezeigt, obwohl eine SIM-Karte in den Slot des Waveshare Base IO Moduls eingelegt war. Auch Versuche mit anderen SIM-Karten nutzten nichts - im System wurde keine Karte erkannt.&lt;/p>
&lt;h3 id="sim-missing-problem-beheben" >&amp;ldquo;SIM Missing&amp;rdquo; Problem beheben
&lt;span>
&lt;a href="#sim-missing-problem-beheben">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h3>&lt;p>&lt;em>(dieses Problem betrifft nur das Telit Modem!)&lt;/em>&lt;/p>
&lt;p>Ein Blick in die &lt;a href="https://www.waveshare.com/w/upload/4/46/CM4-DUAL-ETH-4G_5G-BASE_SchDoc.pdf">Schematics des Waveshare Boards&lt;/a> offenbarte, dass die Signalleitung (&amp;ldquo;CD&amp;rdquo; - &amp;ldquo;Card detect&amp;rdquo;) für die physische Erkennung einer SIM-Karte im Slot nicht zum M.2 Slot weitergeführt wird, sodass das Mobilfunkmodul kein entsprechendes Signal erkennen &lt;em>kann&lt;/em>. Kein Wunder also, dass uns permanent ein &amp;ldquo;&lt;strong>sim-missing&lt;/strong>&amp;rdquo; angezeigt wurde.&lt;/p>
&lt;figure>&lt;img src="images/waveshare-schematics.png"/>&lt;figcaption>
&lt;h4>Screenshot des Waveshare Dual Ethernet IoT Base Boards&lt;/h4>
&lt;/figcaption>
&lt;/figure>
&lt;p>Das Problem lässt sich beheben, indem das Modem so konfiguriert wird, dass es eine immer eingelegte SIM-Karte annimmt und keine HotSwap-Abfragen mehr durchführt. Die Konfiguration geschieht über AT-Kommandos innerhalb einer Terminalsession mit dem Modem selbst:&lt;/p>
&lt;pre>&lt;code>sudo apt install minicom
sudo minicom -D /dev/ttyUSB2
&lt;/code>&lt;/pre>
&lt;p>AT-Kommandos absetzen - sollten mit &amp;ldquo;OK&amp;rdquo; quittiert werden.&lt;/p>
&lt;pre>&lt;code>AT#HSEN=0,0
AT#HSEN=0,1
&lt;/code>&lt;/pre>
&lt;p>&lt;em>(genauer genommen wird hier HotSwap für beide potentiellen SIM-Steckplätze, die das Modem unterstützt, deaktiviert.)&lt;/em>&lt;/p>
&lt;p>Die Minicom Session kann mit CTRL-A gefolgt von &amp;ldquo;X&amp;rdquo; beendet werden.&lt;/p>
&lt;p>Damit die Änderung angewendet wird, wurde das Raspi samt Modem neu gestartet / die Stromversorgung unterbrochen.&lt;/p>
&lt;p>Nach einem Neustart wurde die SIM-Karte im ModemManager schließlich erkannt - am Ende der Ausgabe von &lt;code>mmcli -m 0&lt;/code> wurde eine &amp;ldquo;SIM&amp;rdquo; Zeile mit dem D-Bus Pfad zum SIM-Device eingeblendet:&lt;/p>
&lt;pre>&lt;code>SIM | dbus path: /org/freedesktop/ModemManager1/SIM/0
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>Die soeben erwähnte Anpassung am Telit Modem ist am Quectel-Modem nicht notwendig!&lt;/strong>&lt;/p>
&lt;p>Im nächsten Schritt wird das jeweiligen Modem aktiviert:&lt;/p>
&lt;pre>&lt;code>mmcli -m 0 --enable
&lt;/code>&lt;/pre>
&lt;h3 id="eine-verbindung-mittels-networkmanager-einrichten" >Eine Verbindung mittels NetworkManager einrichten
&lt;span>
&lt;a href="#eine-verbindung-mittels-networkmanager-einrichten">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h3>&lt;p>Mittels NetworkManager wird nun eine neue Mobilfunkverbindung eingerichtet. Dazu legen wir im NetworkManager eine neue &amp;ldquo;Connection&amp;rdquo; an. Im Hintergrund kommuniziert dieser mit dem ModemManager, um APN-Details an ihn weiterzugeben.&lt;/p>
&lt;p>Für unsere Telekom-Karte sind folgende APN-Informationen zu nutzen:&lt;/p>
&lt;ul>
&lt;li>APN: internet.telekom&lt;/li>
&lt;li>IP-Type: ipv4&lt;/li>
&lt;li>Username: telekom&lt;/li>
&lt;li>Password: tm&lt;/li>
&lt;/ul>
&lt;p>Die APN-Informationen eines jeden Providers lassen sich schnell im Internet nachschlagen.&lt;/p>
&lt;p>Mit dem neueren IPv6-fähigen APN der Telekom &lt;code>internet.v6.telekom&lt;/code> (und &amp;ldquo;ipv4v6&amp;rdquo;) hatten wir leider kein Glück - wir konnten keine Vebindung herstellen. Probleme im IPv6-Stack der Modemtreiber sind uns bereits bekannt. Evtl. kommen sie auch hier zum tragen. Daher begnügen wir uns vorerst mit reinem IPv4 Support.&lt;/p>
&lt;p>Bevor die Verbindung angelegt werden kann, muss sichergestellt sein, dass der NetworkManager läuft:&lt;/p>
&lt;pre>&lt;code>systemctl enable --now NetworkManager
&lt;/code>&lt;/pre>
&lt;p>Auf einem Stock Raspberry Pi OS Image ist dies nicht der Fall. Ein Reboot nach dem systemctl Kommando kann nicht schaden. In unserem Fall funktionierte das Zusammenspiel zwischen den beiden Managern erst nach einem Reboot.&lt;/p>
&lt;p>Schließlich wird mit diesem Kommando eine neue GSM Verbindung im NetworkManager angelegt:&lt;/p>
&lt;pre>&lt;code>mmcli c add type gsm ifname cdc-wdm0 con-name telekom apn internet.telekom connection.autoconnect yes
&lt;/code>&lt;/pre>
&lt;p>Im Falle der Telekom ist der APN &amp;ldquo;internet.telekom&amp;rdquo; inkl. der übrigen Parameter bereits im SIM-Profil hinterlegt, sodass nur noch der Name des passenden APN-Profils angegeben werden muss. Auf Benutzername und Passwort kann idR verzichtet werden.&lt;/p>
&lt;p>Sollte das nicht funktionieren, können alternativ auch weitere Parameter mitgegeben werden, wie z.B.&lt;/p>
&lt;pre>&lt;code>mmcli c add type gsm ifname cdc-wdm0 con-name telekom apn internet.telekom gsm.username telekom gsm.password tm gsm.pin 1234 connection.autoconnect yes
&lt;/code>&lt;/pre>
&lt;p>Insbes. die Angabe einer &lt;code>gsm.pin&lt;/code> ist wichtig, falls die SIM-Karte mit einer PIN geschützt ist. Unsere SIM ist nicht mit einer PIN geschützt, daher entfällt die Angabe.&lt;/p>
&lt;p>Ein &lt;code>nmcli c&lt;/code> sollte nun zeigen, dass eine neue Verbindung &amp;ldquo;telekom&amp;rdquo; angelegt wurde. Ist die Verbindung grün markiert, hat die Anmeldung im Netzwerk funktioniert:&lt;/p>
&lt;figure>&lt;img src="images/networkmanager-ok.png"/>&lt;figcaption>
&lt;h4>nmcli c&lt;/h4>
&lt;/figcaption>
&lt;/figure>
&lt;p>Auch der ModemManager sollte nach einer kurzen Weile ähnlich wie hier aussehen und ein &amp;ldquo;connected&amp;rdquo; im Status zeigen: &lt;em>(&lt;code>mmcli -m 0&lt;/code>)&lt;/em>&lt;/p>
&lt;figure>&lt;img src="images/modemmanager-ok.png"/>&lt;figcaption>
&lt;h4>mmcli -m 0&lt;/h4>
&lt;/figcaption>
&lt;/figure>
&lt;h3 id="funktion-prüfen" >Funktion prüfen
&lt;span>
&lt;a href="#funktion-pr%c3%bcfen">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h3>&lt;p>Ob die Mobilfunkverbindung tatsächlich funktioniert, lässt sich schnell und einfach über einen Ping auf dem Mobilfunk-Device prüfen:&lt;/p>
&lt;pre>&lt;code>ping -I wwan0 1.1.1.1
&lt;/code>&lt;/pre>
&lt;p>Die Latenz bewegt sich bei einem 5G NSA Netz üblicherweise bei &amp;gt;= 25 ms, kann aber stark schwanken. Wir haben Latenzen von bis zu 600 ms beobachtet - abhängig von Empfang und Auslastung des Netzwerks.&lt;/p>
&lt;p>Bei einem Neustart des Raspberry Pis wird die Mobilfunkverbindung automatisch neu aufgenommen.&lt;/p>
&lt;p>Übrigens: Ein &lt;code>ip route&lt;/code> offenbart, dass NetworkManager eine Defaultroute für das 5G Modem angelegt hat. Da diese aber mit einer Metrik von 700 versehen ist, wird auf das Mobilfunkmodem nur zurückgegegriffen, falls ein Ziel über eine möglicherwiese vorhandene Ethernetverbindung nicht erreichbar ist. Ein &lt;code>apt update&lt;/code> und alles andere sollte also normalerweise über eine verfügbare Ethernetverbindung laufen. Ist diese nicht verfügbar, dient die Mobilfunkverbindung als Fallback (daher der &lt;code>-I wwan0&lt;/code> Parameter im &lt;code>ping&lt;/code> Kommando - hiermit wird eine Verbindung via Mobilfunk erzwungen).&lt;/p></description></item><item><title>Mobilfunk-Internettraffic außerhalb eines VPNs einschränken</title><link>https://blog.zero-iee.com/posts/traffic-au%C3%9Ferhalb-vpn-verbieten/</link><pubDate>Fri, 12 May 2023 15:17:29 +0200</pubDate><guid>https://blog.zero-iee.com/posts/traffic-au%C3%9Ferhalb-vpn-verbieten/</guid><description>&lt;p>In diesem Beitrag wird erklärt, wie wir die &lt;code>iptables&lt;/code> Firewall eines IoT Gerätes konfiguriert haben, sodass eine Wartung über ein Wireguard VPN-Netz möglich ist, während andere Internetzugriffe aus oder in das Mobilfunknetz verhindert werden.&lt;/p>
&lt;h2 id="gegebenheiten" >Gegebenheiten
&lt;span>
&lt;a href="#gegebenheiten">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;ul>
&lt;li>(Optional) Ethernetverbindung ins Internet via Lokales LAN (&lt;code>eth0&lt;/code>)&lt;/li>
&lt;li>(Optional) LTE-Verbindung ins Internet via USB LTE Modem (&lt;code>usb0&lt;/code>, IP-Adresse &lt;code>192.168.8.1&lt;/code> bzw. &lt;code>fe80::c0b0:4fff:fefe:fefe&lt;/code>)&lt;/li>
&lt;li>Wireguard VPN-Server (&lt;code>vpn.mydomain.tld&lt;/code>)&lt;/li>
&lt;/ul>
&lt;h2 id="ziel" >Ziel
&lt;span>
&lt;a href="#ziel">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;p>Die LTE-Verbindung soll ausschließlich für Verbindungen zum Wireguard-VPN-Server genutzt werden können. Nicht als allgemeine Internetverbindung, da der Traffic der SIM-Karte möglichst gering gehalten werden muss (Beschränkung des Datenvolumens!).&lt;/p>
&lt;p>Für die Übertragung größerer Datenmengen aus dem Internet (OS-Updates, &amp;hellip; ) soll eine optionale Ethernetverbindung genutzt werden.&lt;/p>
&lt;p>Daher: Beschränkung der ausgehenden Verbindungen über &lt;code>usb0&lt;/code> Interface auf Verbindungen zum VPN-Server. Weitere Ausnahmen:&lt;/p>
&lt;ul>
&lt;li>DNS-Anfragen (um Wireguard-Host aufzulösen)&lt;/li>
&lt;li>Ping Requests ins Internet (zum Debugging)&lt;/li>
&lt;/ul>
&lt;p>Die LTE-Schnittstelle wird vom Treiber des Netzwerk-Modems automatisch weniger hoch priorisiert als die Ethernet-Schnittstelle. Ist die Ethernet-Schnittstelle verfügbar, werden Daten bevorzugt hierüber (uneingeschränkt) ausgetauscht.&lt;/p>
&lt;h2 id="implementierung" >Implementierung
&lt;span>
&lt;a href="#implementierung">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;p>&lt;code>iptables&lt;/code> Firewallregel, um allen ausgehenden Traffic über das &lt;code>usb0&lt;/code> interface zu blockieren:&lt;/p>
&lt;pre>&lt;code>sudo iptables -t filter -A OUTPUT -o usb0 -j REJECT
sudo ip6tables -t filter -A OUTPUT -o usb0 -j REJECT
&lt;/code>&lt;/pre>
&lt;p>&lt;em>&lt;strong>Wichtig&lt;/strong>: Die Blockierregel wird mit &lt;code>-A&lt;/code> (&amp;ldquo;append&amp;rdquo;) hinzugefügt. Alle Ausnahmen zu dieser Blockierregel werden im Folgenden mit &lt;code>-I&lt;/code> (&amp;ldquo;insert&amp;rdquo;) hinzugefügt, damit sie in der Abarbeitung / Priorisierung weiter vorne stehen und triggern, bevor es zum &amp;ldquo;REJECT&amp;rdquo; kommt.&lt;/em>&lt;/p>
&lt;p>Verbindungen zum LTE Router selbst erlauben - sonst funktioniert gar nichts mehr:&lt;/p>
&lt;pre>&lt;code>sudo iptables -t filter -I OUTPUT -o usb0 -d 192.168.8.1 -j ACCEPT
sudo ip6tables -t filter -I OUTPUT -o usb0 -d fe80::c0b0:4fff:fefe:fefe -j ACCEPT
&lt;/code>&lt;/pre>
&lt;p>Allerdings müssen Verbindungen zum VPN-Server erlaubt bleiben:&lt;/p>
&lt;pre>&lt;code>sudo iptables -t filter -I OUTPUT -o usb0 -d vpn.mydomain.tld -p udp --dport 51821 -j ACCEPT
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>&lt;em>51821 = Wireguard port&lt;/em>&lt;/li>
&lt;li>&lt;em>Falls der VPN-Server auch via IPv6 erreichbar ist, Kommando mit &lt;code>ip6tables&lt;/code> wiederholen&lt;/em>&lt;/li>
&lt;/ul>
&lt;p>&amp;hellip; und auch zum DNS, denn sonst kann der Hostnamen des Wireguard VPN Servers nicht aufgelöst werden:&lt;/p>
&lt;pre>&lt;code>sudo iptables -t filter -I OUTPUT -o usb0 -p udp --dport 53 -j ACCEPT
sudo ip6tables -t filter -I OUTPUT -o usb0 -p udp --dport 53 -j ACCEPT
&lt;/code>&lt;/pre>
&lt;h2 id="ausgehende-pings-erlauben" >Ausgehende Pings erlauben
&lt;span>
&lt;a href="#ausgehende-pings-erlauben">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;p>Wer zu Debugging-Zwecken ausgehende Pings (ICMP requests) ins LTE-Netz erlauben will, kann eine Ausnahme hinzufügen:&lt;/p>
&lt;pre>&lt;code>sudo iptables -t filter -I OUTPUT -o usb0 -p icmp --icmp-type echo-request -j ACCEPT
sudo ip6tables -t filter -I OUTPUT -o usb0 -p icmpv6 --icmpv6-type echo-request -j ACCEPT
&lt;/code>&lt;/pre>
&lt;h2 id="alle-via-mobilfunk-eingehenden-verbindungen-blockieren" >Alle via Mobilfunk eingehenden Verbindungen blockieren
&lt;span>
&lt;a href="#alle-via-mobilfunk-eingehenden-verbindungen-blockieren">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;p>Um zu verhindern, dass der SSH Port oder ein Webserver direkt aus dem Mobilfunknetz erreicht werden können, wird der Zugriff aus dem Mobilfunknetz weiter eingeschränkt. Services auf dem Target dürfen von außen &lt;em>nur&lt;/em> über das Wireguard VPN erreichbar sein.&lt;/p>
&lt;pre>&lt;code>sudo iptables -t filter -A INPUT -i usb0 -j REJECT
sudo iptables -t filter -I INPUT -i usb0 -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT
sudo ip6tables -t filter -A INPUT -i usb0 -j REJECT
sudo ip6tables -t filter -I INPUT -i usb0 -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT
&lt;/code>&lt;/pre>
&lt;p>Die &lt;code>-m conntrack&lt;/code> Regeln bewirken, dass für eingehende Pakete eine Ausnahme gemacht wird, wenn sie zuvor vom Target selbst angefragt wurden. Schließlich sollen Antworten auf DNS-Anfragen oder Ping-Anfragen das Target weiterhin durchdringen können.&lt;/p>
&lt;h2 id="ergebnis" >Ergebnis
&lt;span>
&lt;a href="#ergebnis">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;pre>&lt;code>pi@target:~ $ sudo iptables -L -t filter -n -v
Chain INPUT (policy ACCEPT 640 packets, 56736 bytes)
pkts bytes target prot opt in out source destination
456 69620 ACCEPT all -- usb0 * 0.0.0.0/0 0.0.0.0/0 ctstate RELATED,ESTABLISHED
0 0 REJECT all -- usb0 * 0.0.0.0/0 0.0.0.0/0 reject-with icmp-port-unreachable
Chain FORWARD (policy ACCEPT 0 packets, 0 bytes)
pkts bytes target prot opt in out source destination
Chain OUTPUT (policy ACCEPT 583 packets, 72865 bytes)
pkts bytes target prot opt in out source destination
3 252 ACCEPT icmp -- * usb0 0.0.0.0/0 0.0.0.0/0 icmptype 8
29 1921 ACCEPT udp -- * usb0 0.0.0.0/0 0.0.0.0/0 udp dpt:53
366 77068 ACCEPT udp -- * usb0 0.0.0.0/0 &amp;lt;vpnip&amp;gt; udp dpt:51821
0 0 ACCEPT all -- * usb0 0.0.0.0/0 192.168.8.1
69 6061 REJECT all -- * usb0 0.0.0.0/0 0.0.0.0/0 reject-with icmp-port-unreachable
&lt;/code>&lt;/pre>
&lt;p>&lt;em>&lt;code>&amp;lt;vpnip&amp;gt;&lt;/code> entspricht hier der aufgelösten IP Adresse zu &lt;code>vpn.mydomain.tld&lt;/code>. &lt;code>51821&lt;/code> ist der genutzte Wireguard Port.&lt;/em>&lt;/p>
&lt;p>Nur Verbindungen, die direkt über das &lt;code>usb0&lt;/code> Interface gehen, werden von der Firewall beschränkt. Verbindungen, die innerhalb des VPN-Netzes hergestellt werden, bleiben unberührt. So kann beispielsweise unbeschränkt über das Wireguard VPN auf den SSH Port und alle weiteren Dienste auf den Targets zugegriffen werden.&lt;/p>
&lt;p>Falls auch Zugriffe innerhalb des VPNs beschränkt werden sollen, können entsprechende &lt;code>iptables&lt;/code> Regeln mit einem &lt;code>-i &amp;lt;wireguardinterface&amp;gt;&lt;/code> Parameter versehen werden, sodass diese nur auf das Wireguard-Interface abzielen.&lt;/p></description></item><item><title>Quectel RM520N-GL 5G Mobilfunkmodem unter Ubuntu Linux in Betrieb nehmen</title><link>https://blog.zero-iee.com/posts/quectel-rm520n-gl-5g-modem-unter-ubuntu-linux/</link><pubDate>Mon, 02 Jan 2023 14:20:04 +0100</pubDate><guid>https://blog.zero-iee.com/posts/quectel-rm520n-gl-5g-modem-unter-ubuntu-linux/</guid><description>&lt;p>Um verschiedene 5G Usecases zu demonstrieren, sollte im Rahmen eines Projekts ein 5G-Modem an einem Ubuntu-basierten Mini PC betrieben werden. Hierzu haben wir uns das RM520N-GL von Quectel besorgt.&lt;/p>
&lt;p>Das Modem wird vom Linux-Kernel erst ab Version 6.0 vollständig unterstützt. Die dazugehörigen Patches sind &lt;a href="https://patchwork.kernel.org/project/linux-usb/patch/tencent_23054B863154DC02C6E98E5942416BFC200A@qq.com/">hier (USB &amp;ldquo;option&amp;rdquo; Treiber)&lt;/a> bzw &lt;a href="https://www.spinics.net/lists/linux-usb/msg230835.html">hier (qmi_wwan Treiber)&lt;/a> zu finden.&lt;/p>
&lt;p>Quectel liefert in der Dokumentation zwar auch Hinweise aus, an welchen Stellen die beteffenden Treiber angepasst werden müssen, doch das erwies sich in unserem Fall als fehleranfällig. Leider werden keine fertigen Git-Patches geliefert, sondern nur Code-Snippets in einem PDF-Dokument.&lt;/p>
&lt;p>Einfacher war es, den Ubuntu 22.04.1 LTS Kernel von Version 5.17 auf Version 6.0.1 anzuheben. Dazu muss der Kernel und seine Module nicht unbedingt neu gebaut werden. Canonical stellt bereits vorkompilierte Kernelartefakte in Form von Debian-Paketen zur Verfügung. Diese werden zwar nicht offiziell unterstützt oder mit Updates versorgt, doch für unsere Demonstrationszwecke war das völlig ausreichend.&lt;/p>
&lt;p>Unter &lt;a href="https://kernel.ubuntu.com/~kernel-ppa/mainline/v6.0.1/">https://kernel.ubuntu.com/~kernel-ppa/mainline/v6.0.1/&lt;/a> werden vier wichtige .deb Pakete zum Download angeboten:&lt;/p>
&lt;ul>
&lt;li>&lt;code>amd64/linux-headers-6.0.1-060001-generic_6.0.1-060001.202210120833_amd64.deb&lt;/code>&lt;/li>
&lt;li>&lt;code>amd64/linux-headers-6.0.1-060001_6.0.1-060001.202210120833_all.deb&lt;/code>&lt;/li>
&lt;li>&lt;code>amd64/linux-image-unsigned-6.0.1-060001-generic_6.0.1-060001.202210120833_amd64.deb&lt;/code>&lt;/li>
&lt;li>&lt;code>amd64/linux-modules-6.0.1-060001-generic_6.0.1-060001.202210120833_amd64.deb&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>Alle vier Dateien werden heruntergeladen und über den Paketmanager installiert:&lt;/p>
&lt;pre>&lt;code>cd Downloads
sudo dkpg -i ./linux*.deb
&lt;/code>&lt;/pre>
&lt;p>Target neu starten - und fertig! Ein &lt;code>uname -r&lt;/code> sollte jetzt die neue kernelversion zeigen. Und auch die aktualisierten USB- und Netzwerktreiber für das Quectel Modem sollten jetzt den Dienst aufnehmen und die passenden Device Nodes unter /dev anlegen:&lt;/p>
&lt;ul>
&lt;li>&lt;code>/dev/cdc-wdm0&lt;/code>&lt;/li>
&lt;li>&lt;code>/dev/ttyUSB0&lt;/code>&lt;/li>
&lt;li>&lt;code>/dev/ttyUSB1&lt;/code>&lt;/li>
&lt;li>&lt;code>/dev/ttyUSB2&lt;/code>&lt;/li>
&lt;li>&lt;code>/dev/ttyUSB3&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>&lt;em>(USB Nodes können je nach angeschlossener Peripherie auch anders nummeriert sein!)&lt;/em>&lt;/p>
&lt;h2 id="eine-verbindung-über-den-networkmanager-und-modemmanager-herstellen" >Eine Verbindung über den NetworkManager und ModemManager herstellen
&lt;span>
&lt;a href="#eine-verbindung-%c3%bcber-den-networkmanager-und-modemmanager-herstellen">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;p>Der &amp;ldquo;schönste&amp;rdquo; Weg führt über die NetworkManager-Integration des ModemManagers. Um zu sehen, ob das Quectel Modem überhaupt als solches vom ModemManager erkannt wurde, kann ein&lt;/p>
&lt;pre>&lt;code>mmcli --modem=0
&lt;/code>&lt;/pre>
&lt;p>ausgeführt werden. Ein paar Informationen zum Modemstatus sollten hier aufgelistet werden.&lt;/p>
&lt;p>Wer eine mit PIN gesicherte SIM-Karte im System nutzt, wird diese zuerst entsperren müssen. Dazu kann über das vorher genannte Kommando zuerst der virtuelle Pfad des SIM-Slots ermittelt werden, z.B.&lt;/p>
&lt;pre>&lt;code>-----------------------------------
SIM | primary sim path: /org/freedesktop/ModemManager1/SIM/0
| sim slot paths: slot 1: /org/freedesktop/ModemManager1/SIM/0 (active)
| slot 2: none
&lt;/code>&lt;/pre>
&lt;p>&amp;hellip; und dann die entsprechende SIM (Index 0) aktiviert werden:&lt;/p>
&lt;pre>&lt;code>mmcli -i=0 --pin=1234
&lt;/code>&lt;/pre>
&lt;p>Wer die SIM permanent entsperrt lassen will, kann die PIN-Sperre entfernen:&lt;/p>
&lt;pre>&lt;code>mmcli -i=0 --pin=1234 --disable-pin
&lt;/code>&lt;/pre>
&lt;p>Sobald die SIM-Karte entsperrt ist, sollte eine Verbindung mit dem Modul möglich sein:&lt;/p>
&lt;pre>&lt;code>nmcli c add type gsm ifname cdc-wdm0 con-name 5g apn internet.telekom
nmcli c up 5g
&lt;/code>&lt;/pre>
&lt;p>Bis sich das Kommando zurückmeldet, können einige Sekunden vergehen. Wir haben hier absichtlich den alten &lt;code>internet.telekom&lt;/code> APN gewählt, weil wir mit dem neueren &amp;ldquo;internet.v6.telekom&amp;rdquo; APN keine Verbindung herstellen konnten. Ursache (noch) unbekannt.&lt;/p>
&lt;h2 id="verbindung-über-das-qmi-network-tool" >Verbindung über das &lt;code>qmi-network&lt;/code> tool
&lt;span>
&lt;a href="#verbindung-%c3%bcber-das-qmi-network-tool">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;p>Statt des Network-/ModemManagers kann für die Verbindungsherstellung auch das &lt;code>qmi-network&lt;/code> Script aus dem &lt;code>libqmi-utils&lt;/code> Paket verwendet werden. Dazu werden in &lt;code>/etc/qmi-network.conf&lt;/code> die richtigen Einstellungen für das Nodem hinterlegt:&lt;/p>
&lt;pre>&lt;code>DEVICE=/dev/cdc-wdm0
DEVICE_OPEN_QMI=YES
PROXY=YES
&lt;/code>&lt;/pre>
&lt;p>Speziell die &lt;code>DEVICE_OPEN_QMI&lt;/code> scheint hier eine wichtige Rolle zu spielen. Anders als in ähnlichen Anleitungen zur Inbetriebnahme von Mobilfunkmodems konnten wir hierauf nicht verzichten.&lt;/p>
&lt;p>Schließlich lässt sich eine Verbindung starten:&lt;/p>
&lt;pre>&lt;code>sudo qmi-network /dev/cdc-wdm0 start
&lt;/code>&lt;/pre>
&lt;p>Allerdings kümmert sich das Script nicht um das Beziehen einer IP-Adresse und der entsprechenden Konfiguration des &lt;code>wwan0&lt;/code> Netzwerkinterfaces. Hier hilft der &lt;code>udhcpc&lt;/code> Client aus dem gleichnamigen Debian-Paket:&lt;/p>
&lt;pre>&lt;code>sudo udhcpc -i wwan0
&lt;/code>&lt;/pre>
&lt;p>Im Idealfall ist nach wenigen Sekunden eine lokale IP-Adresse auf dem &lt;code>wwan0&lt;/code> Interface konfiguriert und lässt eine Kommunikation ins Internet zu:&lt;/p>
&lt;pre>&lt;code>curl ifconfig.me
&lt;/code>&lt;/pre>
&lt;p>zeigt dabei die IP-Adresse an, die für Verbindungen ins Internet aktuell genutzt wird. Es empfiehlt sich, vorher sicherzustellen, dass der Mini-PC über keine Ethernetverbindung ins Internet mehr verfügt. Dazu wird die default-Route zum lokalen Ethernetinterface &lt;code>enp0s29f1&lt;/code> entfernt:&lt;/p>
&lt;pre>&lt;code>sudo ip route del default via 192.168.179.1 dev enp0s29f1
&lt;/code>&lt;/pre>
&lt;p>&lt;em>(kommando anpassen - je nach Output des Kommandos &lt;code>ip route&lt;/code>)&lt;/em>&lt;/p></description></item></channel></rss>