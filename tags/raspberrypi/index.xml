<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>raspberrypi on ZERO GmbH Tech Blog</title><link>https://blog.zero-iee.com/tags/raspberrypi/</link><description>ZERO GmbH Tech Blog (raspberrypi)</description><generator>Hugo -- gohugo.io</generator><language>de</language><lastBuildDate>Wed, 31 May 2023 12:44:58 +0200</lastBuildDate><atom:link href="https://blog.zero-iee.com/tags/raspberrypi/index.xml" rel="self" type="application/rss+xml"/><item><title>Quectel RM520M und Telit FM990A28 5G Modem mit Raspberry Pi OS nutzen</title><link>https://blog.zero-iee.com/posts/quectel-rm520n-and-telit-fn990a28-5g-modems-on-raspberrypi-os/</link><pubDate>Wed, 31 May 2023 12:44:58 +0200</pubDate><guid>https://blog.zero-iee.com/posts/quectel-rm520n-and-telit-fn990a28-5g-modems-on-raspberrypi-os/</guid><description>&lt;p>Auf unserer Odyssee auf der Suche nach einem 5G Mobilfunkmodem haben wir mittlerweile einige Modems verschiedener Hersteller ausprobiert. Leider war die Inbetriebnahme nicht immer erfolgreich. Mal fehlte der Treibersupport im Linux-Kernel gänzlich - mal war die Ansteuerung via NetworkManager / ModemManager fehlerbehaftet oder überhaupt nicht möglich.&lt;/p>
&lt;p>Uns ist eine einfache Inbetriebnahme und ein stabiler Betrieb wichtig. Da wir die Modems nicht nur auf einigen wenigen Geräten einsetzen wollen, kommt für uns eine manuelle Anpassung des Linux-Kernels in der Regel nicht infrage. Zu groß ist der damit verbundene Aufwand und zu unübersichtlich sind die Folgen, die sich daraus für den weiteren Lebenszyklus eines Produkts ergeben. Daher soll das Betriebssystem - oftmals ein Raspberry Pi OS - möglichst im Werkszustand und ohne große Anpassungen genutzt werden.&lt;/p>
&lt;p>&lt;strong>Mittlerweile haben sich für uns zwei Modems herauskristallisiert, die in Kombination mit dem aktuellen &lt;a href="https://www.raspberrypi.com/software/operating-systems/">Raspberry Pi OS&lt;/a> auf Debian 11 &amp;ldquo;Bullseye&amp;rdquo; Basis (Kernel 6.1) &amp;ldquo;out of the box&amp;rdquo; funktionieren:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>&lt;a href="https://www.quectel.com/product/5g-rm520n-gl">Quectel RM520N&lt;/a>&lt;/strong>&lt;/li>
&lt;li>&lt;strong>&lt;a href="https://www.telit.com/devices/fn990axx/">Telit FM990A28&lt;/a>&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>beide 5G Modems unterstützen nicht nur das aktuell weit verbreitete &amp;ldquo;5G New Radio&amp;rdquo; mit LTE Control Plane (NSA), sondern auch 5G NR Standalone (SA), sodass bei einer entsprechenden Ausbaustufe des 5G Mobilfunknetzes auch von extrem niedrigeren Latenzen profitiert werden kann.&lt;/p>
&lt;h2 id="hardware-setup" >Hardware Setup
&lt;span>
&lt;a href="#hardware-setup">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;p>Unser Hardware-Setup für die Evaluierung beider Module sieht wie folgt aus:&lt;/p>
&lt;ul>
&lt;li>Raspberry Pi CM4&lt;/li>
&lt;li>&lt;a href="https://www.waveshare.com/wiki/CM4-DUAL-ETH-4G/5G-BASE">Waveshare Dual Ethernet IoT Base Board&lt;/a> (mit M.2 Slot)&lt;/li>
&lt;li>Telit FM990A28 M.2 Modul &lt;em>oder&lt;/em>&lt;/li>
&lt;li>Quectel RM520N&lt;/li>
&lt;li>IoT SIM-Karte der Deutschen Telekom&lt;/li>
&lt;/ul>
&lt;figure>&lt;img src="images/waveshare-board.jpg"/>&lt;figcaption>
&lt;h4>Waveshare Board mit Quectel 5G Modem&lt;/h4>
&lt;/figcaption>
&lt;/figure>
&lt;h2 id="inbetriebnahme" >Inbetriebnahme
&lt;span>
&lt;a href="#inbetriebnahme">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;p>Die Inbetriebnahme unseres Telit-Moduls lief wie folgt ab: &lt;em>(ähnlich für Quectel!)&lt;/em>&lt;/p>
&lt;p>Überprüfen der Sichtbarkeit des Moduls im USB Subsystem:&lt;/p>
&lt;pre>&lt;code>$ lsusb
&lt;/code>&lt;/pre>
&lt;p>Hier sollte ein Telit Device sichtbar sein:&lt;/p>
&lt;pre>&lt;code>[...]
Bus 002 Device 003: ID 1bc7:1070 Telit Wireless Solutions FN990
[...]
&lt;/code>&lt;/pre>
&lt;p>Auch der ModemManager sollte das Modul erkennen:&lt;/p>
&lt;pre>&lt;code>tom@raspberry:~ $ mmcli -L
/org/freedesktop/ModemManager1/Modem/0 [Telit] FN990A28
&lt;/code>&lt;/pre>
&lt;p>Mittels&lt;/p>
&lt;pre>&lt;code>mmcli -m 0
&lt;/code>&lt;/pre>
&lt;p>Können einige Details zum Modem ausgegeben werden - unter anderem, ob eine Verbindung zum Mobilfunknetz besteht, oder eine SIM-Karte zugeordnet ist.&lt;/p>
&lt;p>Bei unserem ersten Versuch wurde im &amp;ldquo;Status&amp;rdquo; Abschnitt ein rotes &lt;code>sim-missing&lt;/code> angezeigt, obwohl eine SIM-Karte in den Slot des Waveshare Base IO Moduls eingelegt war. Auch Versuche mit anderen SIM-Karten nutzten nichts - im System wurde keine Karte erkannt.&lt;/p>
&lt;h3 id="sim-missing-problem-beheben" >&amp;ldquo;SIM Missing&amp;rdquo; Problem beheben
&lt;span>
&lt;a href="#sim-missing-problem-beheben">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h3>&lt;p>&lt;em>(dieses Problem betrifft nur das Telit Modem!)&lt;/em>&lt;/p>
&lt;p>Ein Blick in die &lt;a href="https://www.waveshare.com/w/upload/4/46/CM4-DUAL-ETH-4G_5G-BASE_SchDoc.pdf">Schematics des Waveshare Boards&lt;/a> offenbarte, dass die Signalleitung (&amp;ldquo;CD&amp;rdquo; - &amp;ldquo;Card detect&amp;rdquo;) für die physische Erkennung einer SIM-Karte im Slot nicht zum M.2 Slot weitergeführt wird, sodass das Mobilfunkmodul kein entsprechendes Signal erkennen &lt;em>kann&lt;/em>. Kein Wunder also, dass uns permanent ein &amp;ldquo;&lt;strong>sim-missing&lt;/strong>&amp;rdquo; angezeigt wurde.&lt;/p>
&lt;figure>&lt;img src="images/waveshare-schematics.png"/>&lt;figcaption>
&lt;h4>Screenshot des Waveshare Dual Ethernet IoT Base Boards&lt;/h4>
&lt;/figcaption>
&lt;/figure>
&lt;p>Das Problem lässt sich beheben, indem das Modem so konfiguriert wird, dass es eine immer eingelegte SIM-Karte annimmt und keine HotSwap-Abfragen mehr durchführt. Die Konfiguration geschieht über AT-Kommandos innerhalb einer Terminalsession mit dem Modem selbst:&lt;/p>
&lt;pre>&lt;code>sudo apt install minicom
sudo minicom -D /dev/ttyUSB2
&lt;/code>&lt;/pre>
&lt;p>AT-Kommandos absetzen - sollten mit &amp;ldquo;OK&amp;rdquo; quittiert werden.&lt;/p>
&lt;pre>&lt;code>AT#HSEN=0,0
AT#HSEN=0,1
&lt;/code>&lt;/pre>
&lt;p>&lt;em>(genauer genommen wird hier HotSwap für beide potentiellen SIM-Steckplätze, die das Modem unterstützt, deaktiviert.)&lt;/em>&lt;/p>
&lt;p>Die Minicom Session kann mit CTRL-A gefolgt von &amp;ldquo;X&amp;rdquo; beendet werden.&lt;/p>
&lt;p>Damit die Änderung angewendet wird, wurde das Raspi samt Modem neu gestartet / die Stromversorgung unterbrochen.&lt;/p>
&lt;p>Nach einem Neustart wurde die SIM-Karte im ModemManager schließlich erkannt - am Ende der Ausgabe von &lt;code>mmcli -m 0&lt;/code> wurde eine &amp;ldquo;SIM&amp;rdquo; Zeile mit dem D-Bus Pfad zum SIM-Device eingeblendet:&lt;/p>
&lt;pre>&lt;code>SIM | dbus path: /org/freedesktop/ModemManager1/SIM/0
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>Die soeben erwähnte Anpassung am Telit Modem ist am Quectel-Modem nicht notwendig!&lt;/strong>&lt;/p>
&lt;p>Im nächsten Schritt wird das jeweiligen Modem aktiviert:&lt;/p>
&lt;pre>&lt;code>mmcli -m 0 --enable
&lt;/code>&lt;/pre>
&lt;h3 id="eine-verbindung-mittels-networkmanager-einrichten" >Eine Verbindung mittels NetworkManager einrichten
&lt;span>
&lt;a href="#eine-verbindung-mittels-networkmanager-einrichten">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h3>&lt;p>Mittels NetworkManager wird nun eine neue Mobilfunkverbindung eingerichtet. Dazu legen wir im NetworkManager eine neue &amp;ldquo;Connection&amp;rdquo; an. Im Hintergrund kommuniziert dieser mit dem ModemManager, um APN-Details an ihn weiterzugeben.&lt;/p>
&lt;p>Für unsere Telekom-Karte sind folgende APN-Informationen zu nutzen:&lt;/p>
&lt;ul>
&lt;li>APN: internet.telekom&lt;/li>
&lt;li>IP-Type: ipv4&lt;/li>
&lt;li>Username: telekom&lt;/li>
&lt;li>Password: tm&lt;/li>
&lt;/ul>
&lt;p>Die APN-Informationen eines jeden Providers lassen sich schnell im Internet nachschlagen.&lt;/p>
&lt;p>Mit dem neueren IPv6-fähigen APN der Telekom &lt;code>internet.v6.telekom&lt;/code> (und &amp;ldquo;ipv4v6&amp;rdquo;) hatten wir leider kein Glück - wir konnten keine Vebindung herstellen. Probleme im IPv6-Stack der Modemtreiber sind uns bereits bekannt. Evtl. kommen sie auch hier zum tragen. Daher begnügen wir uns vorerst mit reinem IPv4 Support.&lt;/p>
&lt;p>Bevor die Verbindung angelegt werden kann, muss sichergestellt sein, dass der NetworkManager läuft:&lt;/p>
&lt;pre>&lt;code>systemctl enable --now NetworkManager
&lt;/code>&lt;/pre>
&lt;p>Auf einem Stock Raspberry Pi OS Image ist dies nicht der Fall. Ein Reboot nach dem systemctl Kommando kann nicht schaden. In unserem Fall funktionierte das Zusammenspiel zwischen den beiden Managern erst nach einem Reboot.&lt;/p>
&lt;p>Schließlich wird mit diesem Kommando eine neue GSM Verbindung im NetworkManager angelegt:&lt;/p>
&lt;pre>&lt;code>mmcli c add type gsm ifname cdc-wdm0 con-name telekom apn internet.telekom connection.autoconnect yes
&lt;/code>&lt;/pre>
&lt;p>Im Falle der Telekom ist der APN &amp;ldquo;internet.telekom&amp;rdquo; inkl. der übrigen Parameter bereits im SIM-Profil hinterlegt, sodass nur noch der Name des passenden APN-Profils angegeben werden muss. Auf Benutzername und Passwort kann idR verzichtet werden.&lt;/p>
&lt;p>Sollte das nicht funktionieren, können alternativ auch weitere Parameter mitgegeben werden, wie z.B.&lt;/p>
&lt;pre>&lt;code>mmcli c add type gsm ifname cdc-wdm0 con-name telekom apn internet.telekom gsm.username telekom gsm.password tm gsm.pin 1234 connection.autoconnect yes
&lt;/code>&lt;/pre>
&lt;p>Insbes. die Angabe einer &lt;code>gsm.pin&lt;/code> ist wichtig, falls die SIM-Karte mit einer PIN geschützt ist. Unsere SIM ist nicht mit einer PIN geschützt, daher entfällt die Angabe.&lt;/p>
&lt;p>Ein &lt;code>nmcli c&lt;/code> sollte nun zeigen, dass eine neue Verbindung &amp;ldquo;telekom&amp;rdquo; angelegt wurde. Ist die Verbindung grün markiert, hat die Anmeldung im Netzwerk funktioniert:&lt;/p>
&lt;figure>&lt;img src="images/networkmanager-ok.png"/>&lt;figcaption>
&lt;h4>nmcli c&lt;/h4>
&lt;/figcaption>
&lt;/figure>
&lt;p>Auch der ModemManager sollte nach einer kurzen Weile ähnlich wie hier aussehen und ein &amp;ldquo;connected&amp;rdquo; im Status zeigen: &lt;em>(&lt;code>mmcli -m 0&lt;/code>)&lt;/em>&lt;/p>
&lt;figure>&lt;img src="images/modemmanager-ok.png"/>&lt;figcaption>
&lt;h4>mmcli -m 0&lt;/h4>
&lt;/figcaption>
&lt;/figure>
&lt;h3 id="funktion-prüfen" >Funktion prüfen
&lt;span>
&lt;a href="#funktion-pr%c3%bcfen">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h3>&lt;p>Ob die Mobilfunkverbindung tatsächlich funktioniert, lässt sich schnell und einfach über einen Ping auf dem Mobilfunk-Device prüfen:&lt;/p>
&lt;pre>&lt;code>ping -I wwan0 1.1.1.1
&lt;/code>&lt;/pre>
&lt;p>Die Latenz bewegt sich bei einem 5G NSA Netz üblicherweise bei &amp;gt;= 25 ms, kann aber stark schwanken. Wir haben Latenzen von bis zu 600 ms beobachtet - abhängig von Empfang und Auslastung des Netzwerks.&lt;/p>
&lt;p>Bei einem Neustart des Raspberry Pis wird die Mobilfunkverbindung automatisch neu aufgenommen.&lt;/p>
&lt;p>Übrigens: Ein &lt;code>ip route&lt;/code> offenbart, dass NetworkManager eine Defaultroute für das 5G Modem angelegt hat. Da diese aber mit einer Metrik von 700 versehen ist, wird auf das Mobilfunkmodem nur zurückgegegriffen, falls ein Ziel über eine möglicherwiese vorhandene Ethernetverbindung nicht erreichbar ist. Ein &lt;code>apt update&lt;/code> und alles andere sollte also normalerweise über eine verfügbare Ethernetverbindung laufen. Ist diese nicht verfügbar, dient die Mobilfunkverbindung als Fallback (daher der &lt;code>-I wwan0&lt;/code> Parameter im &lt;code>ping&lt;/code> Kommando - hiermit wird eine Verbindung via Mobilfunk erzwungen).&lt;/p></description></item><item><title>Waveshare 4 Inch Display funktioniert nicht mit Waveshare CM4 Base IO Module B</title><link>https://blog.zero-iee.com/posts/waveshare-4-inch-display-with-cm4-base-io-b/</link><pubDate>Wed, 26 Apr 2023 14:33:50 +0200</pubDate><guid>https://blog.zero-iee.com/posts/waveshare-4-inch-display-with-cm4-base-io-b/</guid><description>&lt;p>Weil wir es auf die schmerzhafte Weise herausfinden mussten: Das &lt;a href="https://www.waveshare.com/wiki/CM4-IO-BASE-B">Waveshare IO BASE Module B&lt;/a> für das Raspberry Pi CM4 Modul funktioniert &lt;em>nicht&lt;/em> mit dem &lt;a href="https://www.waveshare.com/wiki/4inch_DSI_LCD">4&amp;quot; DSI Touch Display&lt;/a> von Waveshare - zumindest nicht, solange man eine BASE IO Board Revision &amp;lt; 4 verwendet.&lt;/p>
&lt;p>Erst ab Board Version 4 wird die höherperformante DSI1 Schnittstelle statt der DSI0 Schnittstelle des Raspberry CM4 vom IO Base Board genutzt.&lt;/p>
&lt;p>Die Information stammt vom Waveshare-Support, den wir wegen unserer Probleme mit den Display kontaktiert haben. Die Änderung des DSI-Ports mit Version 4 des IO Base Boards ist zwar &lt;a href="https://www.waveshare.com/wiki/CM4-IO-BASE-B#Version_Introduction">dokumentiert&lt;/a>, doch leider befindet sich zum aktuellen Zeitpunkt nirgendwo ein Hinweis auf die fehlende Kompatibilität zum Display - daher sei es hier dokumentiert &amp;hellip; ;-)&lt;/p></description></item><item><title>Waveshare CM4 Dual Gigabit Ethernet 5G/4G Base Board mit Radxa Rock 3 CM3 Compute Module in Betrieb nehmen</title><link>https://blog.zero-iee.com/posts/waveshare-cm4-dual-ethernet-io-board-with-radxa-rock3-cm3/</link><pubDate>Wed, 22 Mar 2023 09:56:25 +0100</pubDate><guid>https://blog.zero-iee.com/posts/waveshare-cm4-dual-ethernet-io-board-with-radxa-rock3-cm3/</guid><description>&lt;p>Da da Raspberry Pi CM4 (&amp;ldquo;Compute Module&amp;rdquo;) seit längerer Zeit wegen der anhaltenden Lieferkettenprobleme schwer und nur in geringen Stückzahlen zu beschaffen ist, haben wir von der ZERO GmbH uns nach einer Alternative umgesehen.&lt;/p>
&lt;p>Obwohl der Name es nicht direkt vermuten lässt, bietet Radxa mit dem &amp;ldquo;&lt;a href="https://wiki.radxa.com/Rock3/CM/CM3">Rock3 CM3&lt;/a>&amp;rdquo; eine weitestgehend Pin-kompatible Alternative zum Raspberry Pi CM4 an. &lt;em>&amp;ldquo;Weitestgehend&amp;rdquo;&lt;/em>, da Radxa über einen zusätzlichen, dritten Sockel weitere Pins für Radxa-spezifische Features anbietet. Weitere Interschiede sind auf &lt;a href="https://wiki.radxa.com/Rock3/CM3/vsCM4">dieser Seite in der Tabelle&lt;/a> zu finden. Dennoch lässt sich das Radxa CM3 Modul hardwareseitig problemlos in ein bestehendes Raspberry Pi CM4 IO-Board einbauen - in unserem Fall ein &lt;a href="https://www.waveshare.com/CM4-DUAL-ETH-4G-5G-BASE.htm">Waveshare Dual Gigabit Ethernet 5G/4G Base Board&lt;/a>.&lt;/p>
&lt;p>Auch wenn die Schnittstelle zwischen CM und Base IO Board nahezu identisch ist - der SoC auf dem Compute Module ist es keinesfalls. Während das CM4 der Raspberry Foundation auf einen Broadcom SoC (BCM2711) setzt, kommt auf dem Radxa Rock3 CM3 ein Rockchip-SoC (RK3566) zum Einsatz. Die Software kann also nicht 1:1 übertragen werden. Ein Raspbian oder Raspberry Pi OS auf dem Rockchip auszuführen, ist also nicht möglich.&lt;/p>
&lt;p>Stattdessen bietet Radxa ein paar für den Rockchip geeignete Betriebssysteme zum Download an. Darunter auch eine Debian 11 (&amp;ldquo;Bullyeye&amp;rdquo;) Version, deren Kernel auf den Rockchip-SoC angepasst ist. Leider kommt die Linux-Distribution mit dem Uraltkernel 4.19 - das soll hier aber erst einmal nicht weiter stören.&lt;/p>
&lt;p>Die &lt;a href="https://wiki.radxa.com/Rock3/downloads">Downloadseite&lt;/a> verweist auf GitHub Releaseseiten. Von dort aus kann die passende Debian-Version heruntergeladen werden. Da wir allerdings nicht das Radxa-eigene IO Board nutzen, sondern das Waveshare IO Board, welches für ein original CM4 konzipiert wurde, ist beim Download Vorsicht geboten: Hier muss die Version für ein &amp;ldquo;RASPCM4IO&amp;rdquo; board heruntergeladen werden. Das Image &lt;code>radxa-cm3-io-debian-bullseye-xfce4-arm64-&amp;lt;VERSION&amp;gt;-gpt.img.xz&lt;/code> ist also das passende (GitHub: &lt;a href="https://github.com/radxa-build/radxa-cm3-io/releases/tag/20221101-0118">Download&lt;/a>).&lt;/p>
&lt;p>Nun aber zu den konkreten Schritten für das Aufspielen des Debian-Images auf den eMMC Flash des Rock3 CM3 - unter Ubuntu Linux als Host. &amp;hellip;&lt;/p>
&lt;h2 id="rkdeveloptool-herunterladen-und-installieren" >rkdeveloptool herunterladen und installieren
&lt;span>
&lt;a href="#rkdeveloptool-herunterladen-und-installieren">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;p>Da wir auf eine SD-Karte verzichten und das OS-Image direkt in den onboard-eMMC Speicher des CM3 schreiben wollen, benötigen wir zunächst das passende Entwicklerwerkzeug von Rockchip, mit dem sich derartige Schreibbvorgänge umsetzen lassen.&lt;/p>
&lt;p>Das passende Tool heißt &lt;code>rkdeveloptool&lt;/code> und kann von GitHub heruntergeladen werden:&lt;/p>
&lt;pre>&lt;code>git clone https://github.com/rockchip-linux/rkdeveloptool.git
&lt;/code>&lt;/pre>
&lt;p>Für den Kompiliervorgang müssen einige Pakete auf dem Host installiert sein:&lt;/p>
&lt;pre>&lt;code>sudo apt-get install build-essential libudev-dev libusb-1.0-0-dev dh-autoreconf
&lt;/code>&lt;/pre>
&lt;p>Danach wird es aus dem Sourcecode kompiliert und installiert:&lt;/p>
&lt;pre>&lt;code>cd rkdeveloptool
autoreconf -i
./configure
make
sudo make install
&lt;/code>&lt;/pre>
&lt;h2 id="os-image-in-emmc-schreiben" >OS-Image in eMMC schreiben
&lt;span>
&lt;a href="#os-image-in-emmc-schreiben">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;p>Nun wird auf dem Waveshare IO Board der &amp;ldquo;Boot&amp;rdquo; Schalter auf &amp;ldquo;on&amp;rdquo; gestellt und das Board mit einem USB-C-Kabel zum Hostrechner verbunden. Ein &lt;code>lsusb&lt;/code> auf der Kommandozeile sollte offenbaren, dass ein Gerät von &amp;ldquo;Fuzhou Rockchip Electronics Company&amp;rdquo; erkannt wurde:&lt;/p>
&lt;pre>&lt;code>Bus 003 Device 005: ID 2207:350a Fuzhou Rockchip Electronics Company
&lt;/code>&lt;/pre>
&lt;p>Nun laden wir uns den Rockchip Loader herunter; eine Softwarekomponente, die in den RAM des SoC geladen wird, sodass wir von dort aus das Debian-Image in den eMMC Flash schreiben können:&lt;/p>
&lt;pre>&lt;code>wget https://dl.radxa.com/rock3/images/loader/rock-3a/rk356x_spl_loader_ddr1056_v1.10.111.bin
&lt;/code>&lt;/pre>
&lt;p>Der Loader wird nun über das rkdeveloptool in den RAM des SoC übertragen:&lt;/p>
&lt;pre>&lt;code>sudo rkdeveloptool db rk356x_spl_loader_ddr1056_v1.10.111.bin
&lt;/code>&lt;/pre>
&lt;p>Nun kann das Debian OS Image von GitHub heruntergeladen und entpackt werden:&lt;/p>
&lt;pre>&lt;code>wget https://github.com/radxa-build/radxa-cm3-io/releases/download/20221101-0118/radxa-cm3-io-debian-bullseye-xfce4-arm64-20221101-0302-gpt.img.xz
xz -d radxa-cm3-io-debian-bullseye-xfce4-arm64-20221101-0302-gpt.img.xz
&lt;/code>&lt;/pre>
&lt;p>Abschließend wird das Debian-Image über den Loader in den eMMC Flash geschrieben:&lt;/p>
&lt;pre>&lt;code>sudo rkdeveloptool wl 0 radxa-cm3-io-debian-bullseye-xfce4-arm64-20221101-0302-gpt.img
&lt;/code>&lt;/pre>
&lt;p>&amp;hellip; und der SoC neu gestartet:&lt;/p>
&lt;pre>&lt;code>sudo rkdeveloptool rd
&lt;/code>&lt;/pre>
&lt;p>Nach dem Neustart sollte auf einem angesteckten HDMI Bildschirm der Bootprozess sichtbar sein. Der &amp;ldquo;Boot&amp;rdquo; Schalter auf dem IO Board kann nun wieder auf &amp;ldquo;off&amp;rdquo; gestellt werden.&lt;/p>
&lt;p>Verbindet man das IO Board via Ethernet mit dem lokalen Netzwerk, ist das Radxa Modul über den Hostnamen &lt;code>radxa-cm3-io&lt;/code> erreichbar:&lt;/p>
&lt;pre>&lt;code>ssh rock@radxa-cm3-io
&lt;/code>&lt;/pre>
&lt;p>Standard-Logindaten sind&lt;/p>
&lt;ul>
&lt;li>Username: &lt;code>rock&lt;/code>&lt;/li>
&lt;li>Password: &lt;code>rock&lt;/code>&lt;/li>
&lt;/ul>
&lt;h2 id="apt-aktualisieren" >APT aktualisieren
&lt;span>
&lt;a href="#apt-aktualisieren">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;p>Direkt nach der Installation konnten wir in unserem konkreten Fall keine Paketupdates für Debian einspielen, da Uhrzeit und Datum noch nicht korrekt eingestellt waren. Das ließ sich mittels&lt;/p>
&lt;pre>&lt;code>sudo systemctl restart ntp.service
&lt;/code>&lt;/pre>
&lt;p>schnell beheben.&lt;/p>
&lt;p>Zudem wurde mindestens ein APT Repository nicht also gültig erkannt, weil ein PGP-Schlüssel nicht aktuell war:&lt;/p>
&lt;pre>&lt;code>$ sudo apt update &amp;amp;&amp;amp; apt upgrade -y
W: GPG error: http://apt.radxa.com/bullseye-stable bullseye InRelease: The following signatures couldn't be verified because the public key is not available: NO_PUBKEY 9B98116C9AA302C7
&lt;/code>&lt;/pre>
&lt;p>Auch dieses Problem ließ sich mit einem einzigen Kommando schnell beseitigen:&lt;/p>
&lt;pre>&lt;code>wget -O - apt.radxa.com/$(lsb_release -c -s)-stable/public.key | sudo apt-key add -
&lt;/code>&lt;/pre>
&lt;p>Danach funktionierte auch ein &lt;code>sudo apt update&lt;/code> wieder einwandfrei.&lt;/p></description></item><item><title>Schlechte Qt Grafikperformance mit Raspi4</title><link>https://blog.zero-iee.com/posts/schlechte-qt-grafik-performance-mit-raspi4/</link><pubDate>Tue, 07 Feb 2023 08:19:47 +0100</pubDate><guid>https://blog.zero-iee.com/posts/schlechte-qt-grafik-performance-mit-raspi4/</guid><description>&lt;p>Während der Entwicklung einer Qt-basierten Anwendung auf einem Raspberry Pi 4 (CM) sind wir von der ZERO GmbH vor ein paar Tagen auf ein kurioses Problem gestoßen: Die Anwendung beinhaltet zwei Anwendungsfenster - ein QT Quick Fenster und ein weiteres Fenster, das mittels WebEngine (Chromium) eine Webanwendung darstellt. Die Inhalte in beiden Fenstern wurden während des Debuggings und beim manuellen Starten der Binärdatei aus der Kommandozeile heraus flüssig dargestellt. Bei Animationen und Mausbewegungen konnten wir keine bemerkenswerten Ruckler feststellen.&lt;/p>
&lt;p>Doch nach einem Start während des Boot-Prozesses durch ein Systemd Service-File sah die Sache schon ganz anders aus: Die Darstellung ruckelte stark und die CPU-Auslastung lag bereits bei einfachen Texteinblendungen bei ca 80 %.&lt;/p>
&lt;p>Wir konnten einen Zusammenhang zwischen dem Startzeitpunkt der Anwendung und der Performance feststellen. In frühen Bootphasen war die Performance schlecht - bei späterer Ausführung lief die Anwendung flüssig. Durch ein &amp;ldquo;sleep&amp;rdquo; Kommando in unserem Systemd Service File konnten wir den Zusammenhang verdeutlichen:&lt;/p>
&lt;pre tabindex="0">&lt;code>[Unit]
Description=App
[Service]
User=pi
Group=pi
Type=simple
ExecStart=/bin/bash -c &amp;#39;sleep 10; /opt/myapp/myapp -platform=eglfs&amp;#39;
[Install]
WantedBy=multi-user.target
&lt;/code>&lt;/pre>&lt;p>Alleine schon eine Verzögerung der Ausführung um 10 Sekunden führte zum gewünschten Ergebnis. Dies war jedoch keine Zufriedenstellende Lösung - schließlich wollten wir die Qt-Anwendung so schnell wie möglich starten und nicht unnötig Zeit verlieren, ohne den Grund für das Verhalten zu kennen.&lt;/p>
&lt;p>Ein Blick in das Systemlog offenbarte schließlich, dass unsere Anwendung den LLVMpipe Rasterizer nutze, wenn sie über ein Service-File gestartet wurde:&lt;/p>
&lt;pre tabindex="0">&lt;code>&amp;#34;Feb 03 04:33:29 raspberrypi bash[470]: Running on a software rasterizer (LLVMpipe), expect limited performance.&amp;#34;
&lt;/code>&lt;/pre>&lt;p>Letztendlich konnten wir das Performanceproblem nach einigen Websuchen durch ein Hinzufügen unseres &lt;code>pi&lt;/code> Benutzers zur Benutzergruppe &lt;code>render&lt;/code> (und einen Anschließenden Neustart) beheben:&lt;/p>
&lt;pre tabindex="0">&lt;code>sudo usermod -aG render pi
&lt;/code>&lt;/pre>&lt;p>Nach &lt;a href="https://www.hardwareluxx.de/community/threads/raspberry-pi-os-und-ein-paar-fehler-beim-%C3%B6ffnen-eines-programmes.1272595/post-27563953">Aussage des Forennutzers &lt;em>&amp;ldquo;cRaZy-biScuiT&amp;rdquo;&lt;/em>&lt;/a> wird damit ein Bug behoben, der dafür sorgt, dass Anwendungen unter dem &lt;code>pi&lt;/code> User keine hardwarebeschleunigten Anwendungen ausführen können.&lt;/p>
&lt;p>Unsere Qt-Anwendung startete nun auch schon in früheren Bootphasen inkl. Hardwareunterstützung und die Performance war wie erwartet.&lt;/p>
&lt;p>Bisher können wir allerdings nicht erklären, wieso das Problem zu späteren Startzeitpunkten nicht auftrat. Wir vermuten eine externe Beeinflussung evtl. durch später startende, dritte Anwendungen, die dafür sorgte, dass die Hardwarebeschleunigung zu diesen Zeitpunkten dennoch zur Verfügung stand.&lt;/p></description></item></channel></rss>