<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>qt on ZERO GmbH Tech Blog</title><link>https://blog.zero-iee.com/en/tags/qt/</link><description>ZERO GmbH Tech Blog (qt)</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Tue, 26 Sep 2023 09:39:39 +0200</lastBuildDate><atom:link href="https://blog.zero-iee.com/en/tags/qt/index.xml" rel="self" type="application/rss+xml"/><item><title>Prevent DSI output errors when starting a Qt application (Raspberry Pi)</title><link>https://blog.zero-iee.com/en/posts/resolving-qt-dsi-failed-to-move-flip-permission-denied-error/</link><pubDate>Tue, 26 Sep 2023 09:39:39 +0200</pubDate><guid>https://blog.zero-iee.com/en/posts/resolving-qt-dsi-failed-to-move-flip-permission-denied-error/</guid><description>&lt;p>Yesterday, while completing some of our AMPS units with display and Qt application, we encountered an error that caused the application to fail to launch correctly and crash in rare cases. The error looks like this:&lt;/p>
&lt;pre tabindex="0">&lt;code>-- Logs begin at Mon 2023-09-25 12:17:01 CEST, end at Mon 2023-09-25 12:32:43 CEST. --
Sep 25 12:32:24 0601-010200-0012 systemd[1]: Started app.
Sep 25 12:32:27 0601-010200-0012 tester[444]: Failed to move cursor on screen DSI1: -13
Sep 25 12:32:27 0601-010200-0012 tester[444]: Failed to move cursor on screen DSI1: -13
Sep 25 12:32:27 0601-010200-0012 tester[444]: Could not set cursor on screen DSI1: -13
Sep 25 12:32:28 0601-010200-0012 tester[444]: Could not set DRM mode for screen DSI1 (Permission denied)
Sep 25 12:32:28 0601-010200-0012 tester[444]: Could not queue DRM page flip on screen DSI1 (Permission denied)
Sep 25 12:32:29 0601-010200-0012 tester[444]: Could not queue DRM page flip on screen DSI1 (Permission denied)
&lt;/code>&lt;/pre>&lt;p>&amp;ldquo;In rare cases&amp;rdquo;, because the bug was apparently timing-dependent. However, because we were not completely unaware of the error messages, we were able to find out relatively quickly where they were coming from:&lt;/p>
&lt;p>Our application runs in EGLFS mode and claims complete control over the display. There is no XServer, Wayland or similar running in the background. The error messages indicate a permission problem, but actually come from the fact that another application is already exerting control over the display.&lt;/p>
&lt;p>In our case: The boot splash screen (&lt;code>plymouth&lt;/code>) of our Rasbian distribution. The error occurs only about 1-2 times out of 10, because in most cases systemd starts the application at a time when the display has already been released. Depending on the boot time - which can vary slightly - it can happen that the timing is so unfavorable that the splash screen has &lt;em>not&lt;/em> released the display when our application already wants to use it.&lt;/p>
&lt;p>Fortunately, this problem can be solved by adding another dependency to the systemd service of our application via &lt;code>After&lt;/code>, e.g.&lt;/p>
&lt;pre>&lt;code>[Unit]
Description=App
After=systemd-user-sessions.service plymouth-quit.service
[Service]
Type=simple
User=pi
Group=pi
ExecStart=/opt/tester/bin/tester -platform=eglfs
[Install]
WantedBy=multi-user.target
&lt;/code>&lt;/pre>
&lt;p>&lt;em>By the way: In this context, it may also be worthwhile to check whether the user running the application is in the &amp;ldquo;render&amp;rdquo; user group. The group membership is required in order to be allowed to access the display as an application via eglfs at all.&lt;/em>&lt;/p></description></item><item><title>Qt 5.15.2 with WebEngine (Chromium) - Limit RAM usage to avoid crashes</title><link>https://blog.zero-iee.com/en/posts/qt-5.15.2-mit-webengine-ram-begrenzen/</link><pubDate>Wed, 11 Jan 2023 14:19:06 +0100</pubDate><guid>https://blog.zero-iee.com/en/posts/qt-5.15.2-mit-webengine-ram-begrenzen/</guid><description>&lt;p>When compiling Qt 5.15.2 from the official open source sources, we encountered a problem in combination with our build server: The build process was interrupted while compiling the Chromium-based &amp;ldquo;WebEngine&amp;rdquo; component with initially mysterious error messages. A look at the kernel log using &lt;code>dmesg -w&lt;/code> then quickly revealed that the so-called OOM killer of the Linux kernel had struck. Apparently the RAM consumption of the build process was so memory-intensive that the process had to be aborted to keep the operating system running.&lt;/p>
&lt;p>But how could this be? Our build server has 32 GB of RAM and 24 CPU cores. A quite powerful machine. It should not actually reach its performance limits so quickly.&lt;/p>
&lt;p>The problem is caused by two factors. First, building the Chromium browser engine is extremely memory intensive. Generally, &lt;a href="https://chromium.googlesource.com/chromium/src/+/main/docs/linux/build_instructions.md">not less than 16 GB RAM is recommended&lt;/a>. In our case, however, there is another problem: By default, &amp;ldquo;Ninja&amp;rdquo; - the build system used in Chromium - creates a build thread for each available virtual CPU core, so that the build process is parallelized to the maximum. What may still work well for a standard PC with 16 GB RAM, however, forces our build server with its 24 cores to its knees. Every single thread needs a not to be underestimated amount of RAM. In the end, the ratio of CPU cores and available RAM is no longer correct on our server, so the build process stops.&lt;/p>
&lt;p>The problem can be prevented if we artificially reduce the number of Ninja threads to be used - if we don&amp;rsquo;t build with 24 CPU cores, for example, but only with 18.&lt;/p>
&lt;p>For this purpose the environment variable &lt;code>NINJAJOBS&lt;/code> can be set before a &lt;code>make -j$(nproc)&lt;/code>. Contrary to what one might expect &lt;em>(and contrary to what is described in the &lt;a href="https://www.linuxfromscratch.org/blfs/view/svn/x/qtwebengine.html">LFS manual&lt;/a>)&lt;/em>, however, not just a number is stored here, but the complete &lt;code>-j&lt;/code> &lt;a href="https://manpages.debian.org/testing/ninja-build/ninja.1.en.html">parameter of Ninja&lt;/a>:&lt;/p>
&lt;pre>&lt;code>export NINJAJOBS=&amp;quot;-j16&amp;quot;
&lt;/code>&lt;/pre>
&lt;p>If a &lt;code>make&lt;/code> is subsequently executed, the usual Qt components are compiled with all cores, while the Ninja-based parts (in this case Chromium as part of the WebEngine) are built with fewer CPU cores to conserve RAM.&lt;/p>
&lt;p>For our combination of 32 GB RAM and 24 CPU cores, we experimentally determined a count of 16 kernels with which to still run our build process. With only 8 CPU cores, RAM usage peaked at about 12 GB.&lt;/p></description></item></channel></rss>