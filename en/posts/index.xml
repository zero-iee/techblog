<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on ZERO GmbH Tech Blog</title><link>https://blog.zero-iee.com/en/posts/</link><description>ZERO GmbH Tech Blog (Posts)</description><generator>Hugo -- gohugo.io</generator><language>de-de</language><lastBuildDate>Fri, 27 Jan 2023 12:17:09 +0100</lastBuildDate><atom:link href="https://blog.zero-iee.com/en/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Pistache REST API Server Returns Incorrect Responses to Requests</title><link>https://blog.zero-iee.com/en/posts/pistache-rest-api-server-gibt-falsche-daten-zur%C3%BCck/</link><pubDate>Fri, 27 Jan 2023 12:17:09 +0100</pubDate><guid>https://blog.zero-iee.com/en/posts/pistache-rest-api-server-gibt-falsche-daten-zur%C3%BCck/</guid><description>&lt;p>Until a few hours ago we had to deal with a strange bug related to the C++ HTTP library &amp;ldquo;&lt;a href="https://pistacheio.github.io/pistache/">Pistache&lt;/a>&amp;rdquo;, which could not be identified completely at first. Maybe we are not the only ones - so in this post we want to briefly present the setup and our fix.&lt;/p>
&lt;p>The environment consists of a C++ based backend from which data is to be read via a REST API and displayed in a web browser.&lt;/p>
&lt;p>The request of the data from the API is done via a Javascript. We work without a library - quite traditionally using &lt;a href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest">XMLHttpRequest&lt;/a>. Since several different data sets are displayed on the website, several parallel &lt;a href="https://de.wikipedia.org/wiki/Ajax_(programming)">Ajax&lt;/a> requests to the REST API are periodically formulated and transmitted in the background.&lt;/p>
&lt;p>&lt;strong>The problem was that we - seemingly randomly - kept getting Ajax responses back that we had not requested in this context.&lt;/strong> For example, if a request for all available cars was sent, we got the response for the request for all available ships. In parallel, all available ships were also requested in the background - but just not in &lt;em>the&lt;/em> function that was responsible for the cars. It seemed that the answers to HTTP requests were partially mixed.&lt;/p>
&lt;p>The first assumption was that we had a bug in our Javascript and were overwriting variables with each other on simultaneous requests. However, after careful checking and clearly renaming the variables involved, we were able to rule that out.&lt;/p>
&lt;p>A bug in the web browser that caused requests and responses to get mixed up? Unlikely. The problem occurred in both the Chromium and Firefox web browsers.&lt;/p>
&lt;p>Then it had to be the backend. We started to examine the backend more closely. It turned out that the problems only occurred when a certain HTTP handler function was called. This custom function is called by the Pistache library when a request is received. Within the function, the parameters of the request can be checked and processed, and a suitable response can be formulated.&lt;/p>
&lt;p>By gradually commenting out within the function and reducing it to the essentials (namely, sending a suitable response to the web browser), we were finally able to narrow down the problem.&lt;/p>
&lt;p>Within the function there was the following code section:&lt;/p>
&lt;pre tabindex="0">&lt;code>void ApiHandler::getVehicle(const Rest::Request &amp;amp;request, Http::ResponseWriter response){
json j;
[...]
if (myModel-&amp;gt;getType() == &amp;#34;car&amp;#34;) {
[...]
j[&amp;#34;licensePlate&amp;#34;] = car-&amp;gt;getLicensePlate();
j[&amp;#34;owner&amp;#34;] = car-&amp;gt;getOwnerName();
response.send(Http::Code::Ok, j.dump() + &amp;#39;\n&amp;#39;); // Respond with JSON string
} else if (myModel-&amp;gt;getType() == &amp;#34;ship&amp;#34;) {
[...]
j[&amp;#34;homeCountry&amp;#34;] = car-&amp;gt;getHomeCountry();
j[&amp;#34;owner&amp;#34;] = car-&amp;gt;getOwnerName();
response.send(Http::Code::Ok, j.dump() + &amp;#39;\n&amp;#39;); // Respond with JSON string
}
response.send(Http::Code::Unprocessable_Entity);
}
&lt;/code>&lt;/pre>&lt;p>Found the mistake? Quite simple: The intention was to return an &amp;ldquo;Unprocessable_Entity&amp;rdquo; error if the function was executed for a model other than a &amp;ldquo;Car&amp;rdquo; or &amp;ldquo;Ship&amp;rdquo; model. However, an &lt;code>else&lt;/code> was forgotten. Correctly it should be like this:&lt;/p>
&lt;pre tabindex="0">&lt;code> else {
response.send(Http::Code::Unprocessable_Entity);
}
&lt;/code>&lt;/pre>&lt;p>Omitting the &lt;code>else&lt;/code> here is possible in cases where the further processing of the function is stopped by &amp;ldquo;return&amp;rdquo;. But not here - in our case the error leads to &lt;code>response.send&lt;/code> being run twice in most cases.&lt;/p>
&lt;p>The Pistache HTTP server does not seem to be able to cope with this and behaves &lt;em>undefined&lt;/em>. We did not investigate further within the Pistache library, but it seemed worth mentioning that the library behaves unpredictably in such a case and apparently even mixes up responses to concurrent HTTP requests.&lt;/p>
&lt;p>So if you are struggling with an uncontrollably behaving Pistache server, you might want to check your code for duplicate response.send() statements.&lt;/p></description></item><item><title>Qt 5.15.2 with WebEngine (Chromium) - Limit RAM usage to avoid crashes</title><link>https://blog.zero-iee.com/en/posts/qt-5.15.2-mit-webengine-ram-begrenzen/</link><pubDate>Wed, 11 Jan 2023 14:19:06 +0100</pubDate><guid>https://blog.zero-iee.com/en/posts/qt-5.15.2-mit-webengine-ram-begrenzen/</guid><description>&lt;p>When compiling Qt 5.15.2 from the official open source sources, we encountered a problem in combination with our build server: The build process was interrupted while compiling the Chromium-based &amp;ldquo;WebEngine&amp;rdquo; component with initially mysterious error messages. A look at the kernel log using &lt;code>dmesg -w&lt;/code> then quickly revealed that the so-called OOM killer of the Linux kernel had struck. Apparently the RAM consumption of the build process was so memory-intensive that the process had to be aborted to keep the operating system running.&lt;/p>
&lt;p>But how could this be? Our build server has 32 GB of RAM and 24 CPU cores. A quite powerful machine. It should not actually reach its performance limits so quickly.&lt;/p>
&lt;p>The problem is caused by two factors. First, building the Chromium browser engine is extremely memory intensive. Generally, &lt;a href="https://chromium.googlesource.com/chromium/src/+/main/docs/linux/build_instructions.md">not less than 16 GB RAM is recommended&lt;/a>. In our case, however, there is another problem: By default, &amp;ldquo;Ninja&amp;rdquo; - the build system used in Chromium - creates a build thread for each available virtual CPU core, so that the build process is parallelized to the maximum. What may still work well for a standard PC with 16 GB RAM, however, forces our build server with its 24 cores to its knees. Every single thread needs a not to be underestimated amount of RAM. In the end, the ratio of CPU cores and available RAM is no longer correct on our server, so the build process stops.&lt;/p>
&lt;p>The problem can be prevented if we artificially reduce the number of Ninja threads to be used - if we don&amp;rsquo;t build with 24 CPU cores, for example, but only with 18.&lt;/p>
&lt;p>For this purpose the environment variable &lt;code>NINJAJOBS&lt;/code> can be set before a &lt;code>make -j$(nproc)&lt;/code>. Contrary to what one might expect &lt;em>(and contrary to what is described in the &lt;a href="https://www.linuxfromscratch.org/blfs/view/svn/x/qtwebengine.html">LFS manual&lt;/a>)&lt;/em>, however, not just a number is stored here, but the complete &lt;code>-j&lt;/code> &lt;a href="https://manpages.debian.org/testing/ninja-build/ninja.1.en.html">parameter of Ninja&lt;/a>:&lt;/p>
&lt;pre>&lt;code>export NINJAJOBS=&amp;quot;-j16&amp;quot;
&lt;/code>&lt;/pre>
&lt;p>If a &lt;code>make&lt;/code> is subsequently executed, the usual Qt components are compiled with all cores, while the Ninja-based parts (in this case Chromium as part of the WebEngine) are built with fewer CPU cores to conserve RAM.&lt;/p>
&lt;p>For our combination of 32 GB RAM and 24 CPU cores, we experimentally determined a count of 16 kernels with which to still run our build process. With only 8 CPU cores, RAM usage peaked at about 12 GB.&lt;/p></description></item><item><title>Hello World!</title><link>https://blog.zero-iee.com/en/posts/hello-world/</link><pubDate>Tue, 20 Dec 2022 06:08:14 -0800</pubDate><guid>https://blog.zero-iee.com/en/posts/hello-world/</guid><description>&lt;p>Welcome to the Tech Blog of &lt;a href="https://zero-iee.com">ZERO GmbH&lt;/a>!&lt;/p>
&lt;p>Soon we will present here experiences and notes from our technical development, in the hope that they will be helpful for others.&lt;/p></description></item></channel></rss>